[
  {
    "name": "Kai",
    "description": "このプログラムは、Google Colab 上で動作する コンソール版オセロゲーム です。 8×8の盤面をリストで管理し、プレイヤーは座標を入力して石を置きます。置いた場所から縦・横・斜めの8方向を探索し、相手の石を挟んだ場合のみ合法手として認め、石を裏返します。手番は黒→白の順に交互で、両者が打てない状況になるとゲーム終了し、石数をカウントして勝敗を表示します。  工夫した点 \t•\tコードを関数ごとに分け、理解・修正しやすいようにした \t•\t合法手判定・反転処理を汎用的にすることで拡張しやすくした \t•\t入力ミスに対して再入力を要求するようにした \t•\t今後GUIに発展できるような構造を意識して設計",
    "code": "# -*- coding: utf-8 -*-\n# Google Colab で動かすオセロゲーム（コンソール版）\n# 黒＝B、白=W。行と列を数字で入力してプレイします。\n\nimport numpy as np\n\n# 初期盤面生成\ndef init_board():\n    board = np.zeros((8,8), dtype=str)\n    board[:] = \".\"\n    board[3][3] = board[4][4] = \"W\"\n    board[3][4] = board[4][3] = \"B\"\n    return board\n\n# 盤面表示\ndef display(board):\n    print(\"  0 1 2 3 4 5 6 7\")\n    for i,row in enumerate(board):\n        print(i, \" \".join(row))\n    print()\n\n# ひっくり返せる石を探索\ndef check_direction(board, r, c, dr, dc, color):\n    enemy = \"W\" if color==\"B\" else \"B\"\n    r += dr; c += dc\n    flips = []\n    while 0<=r<8 and 0<=c<8 and board[r][c]==enemy:\n        flips.append((r,c))\n        r += dr; c += dc\n    if 0<=r<8 and 0<=c<8 and board[r][c]==color and flips:\n        return flips\n    return []\n\n# 合法手判定\ndef valid_moves(board, color):\n    moves = []\n    for r in range(8):\n        for c in range(8):\n            if board[r][c]!=\".\": continue\n            flips=[]\n            for dr in [-1,0,1]:\n                for dc in [-1,0,1]:\n                    if dr!=0 or dc!=0:\n                        flips += check_direction(board,r,c,dr,dc,color)\n            if flips:\n                moves.append((r,c))\n    return moves\n\n# 石を置く処理\ndef place(board,r,c,color):\n    all_flips=[]\n    for dr in [-1,0,1]:\n        for dc in [-1,0,1]:\n            if dr!=0 or dc!=0:\n                all_flips+=check_direction(board,r,c,dr,dc,color)\n    if not all_flips: return False\n    board[r][c]=color\n    for fr,fc in all_flips:\n        board[fr][fc]=color\n    return True\n\n# ----ゲーム開始----\nboard=init_board()\nturn=\"B\"  # 先手は黒\n\nwhile True:\n    display(board)\n    moves = valid_moves(board, turn)\n    if not moves:\n        print(f\"{turn} has no moves. Pass.\")\n        turn = \"W\" if turn==\"B\" else \"B\"\n        if not valid_moves(board,turn):\n            print(\"Game Over!\")\n            break\n        continue\n\n    print(f\"Turn: {turn}   Movable: {moves}\")\n    try:\n        r = int(input(\"row: \"))\n        c = int(input(\"col: \"))\n    except:\n        print(\"数字を入力してください。\")\n        continue\n\n    if (r,c) in moves:\n        place(board,r,c,turn)\n        turn = \"W\" if turn==\"B\" else \"B\"\n    else:\n        print(\"その場所には置けません。再入力してください。\")\n\n# 結果表示\nb = np.sum(board==\"B\")\nw = np.sum(board==\"W\")\nprint(f\"Black={b}, White={w}\")\nprint(\"Winner:\", \"Black\" if b>w else \"White\" if w>b else \"Draw\")"
  },
  {
    "name": "Shimon",
    "description": "東大王のクイズ×オセロを自分の好きな日本史に置き換えて作りました。",
    "code": "# ========================================\n# 日本史クイズオセロ（早慶上智レベル）\n# Google Colab用Pythonプログラム\n# ========================================\n\nimport random\n\nclass QuizOthello:\n    \"\"\"\n    日本史クイズと組み合わせたオセロゲーム\n    石を置く前にクイズに正解する必要がある独創的なルール\n    \"\"\"\n    \n    def __init__(self):\n        # 定数定義\n        self.BOARD_SIZE = 8\n        self.EMPTY = 0\n        self.BLACK = 1\n        self.WHITE = 2\n        \n        # ゲーム状態の初期化\n        self.board = [[self.EMPTY] * self.BOARD_SIZE for _ in range(self.BOARD_SIZE)]\n        self.current_player = self.BLACK\n        self.initialize_board()\n        \n        # 日本史クイズデータベース（50問）\n        self.quiz_db = [\n            # 古代史\n            {\"q\": \"律令制下の租税で、地方の特産物を納める税は何か？\", \"a\": [\"調\", \"庸\", \"租\", \"雑徭\"], \"c\": 0, \"type\": \"choice\"},\n            {\"q\": \"645年の改新の詔で廃止された、豪族が私有していた土地・人民を何というか？（ひらがな）\", \"ans\": \"みやけ\", \"type\": \"text\"},\n            {\"q\": \"701年に制定された律令を何というか？\", \"a\": [\"大宝律令\", \"養老律令\", \"令義解\", \"律令格式\"], \"c\": 0, \"type\": \"choice\"},\n            {\"q\": \"奈良時代、国司の監督のため派遣された中央官僚を何というか？（ひらがな）\", \"ans\": \"あぜち\", \"type\": \"text\"},\n            {\"q\": \"平城京から長岡京への遷都を行った天皇は誰か？\", \"a\": [\"桓武天皇\", \"聖武天皇\", \"光仁天皇\", \"嵯峨天皇\"], \"c\": 0, \"type\": \"choice\"},\n            {\"q\": \"894年に遣唐使の停止を建議した人物は誰か？（ひらがな）\", \"ans\": \"すがわらのみちざね\", \"type\": \"text\"},\n            {\"q\": \"藤原道長の権勢を示す和歌の下の句は？\", \"a\": [\"欠けたることもなしと思へば\", \"かくれてくもなきものを\", \"満ちたることもなしと思へば\", \"曇りなきものと思へば\"], \"c\": 0, \"type\": \"choice\"},\n            \n            # 中世史\n            {\"q\": \"1156年の保元の乱で勝利した後、実権を握った上皇は誰か？\", \"a\": [\"後白河上皇\", \"崇徳上皇\", \"鳥羽上皇\", \"白河上皇\"], \"c\": 0, \"type\": \"choice\"},\n            {\"q\": \"1185年、源頼朝が朝廷から得た、守護・地頭の設置権を何というか？\", \"a\": [\"文治の勅許\", \"建久の勅許\", \"寿永の宣旨\", \"養和の宣旨\"], \"c\": 0, \"type\": \"choice\"},\n            {\"q\": \"鎌倉幕府の訴訟・裁判を担当した機関は何か？（ひらがな）\", \"ans\": \"もんちゅうじょ\", \"type\": \"text\"},\n            {\"q\": \"1221年の承久の乱後、朝廷を監視するために京都に設置された機関は？\", \"a\": [\"六波羅探題\", \"鎌倉府\", \"京都所司代\", \"京都守護職\"], \"c\": 0, \"type\": \"choice\"},\n            {\"q\": \"1232年、北条泰時が制定した武家法典は何か？\", \"a\": [\"御成敗式目\", \"建武式目\", \"武家諸法度\", \"禁中並公家諸法度\"], \"c\": 0, \"type\": \"choice\"},\n            {\"q\": \"1274年と1281年の元寇で、執権として防衛にあたったのは誰か？\", \"a\": [\"北条時宗\", \"北条泰時\", \"北条義時\", \"北条高時\"], \"c\": 0, \"type\": \"choice\"},\n            {\"q\": \"足利義満が朝廷から受けた最高位の官職は何か？\", \"a\": [\"太政大臣\", \"関白\", \"征夷大将軍\", \"左大臣\"], \"c\": 0, \"type\": \"choice\"},\n            {\"q\": \"室町時代、明との貿易で使用された合札を何というか？（ひらがな）\", \"ans\": \"かんごう\", \"type\": \"text\"},\n            {\"q\": \"1467年に始まり、戦国時代の幕開けとなった乱は何か？\", \"a\": [\"応仁の乱\", \"享徳の乱\", \"永享の乱\", \"嘉吉の乱\"], \"c\": 0, \"type\": \"choice\"},\n            \n            # 近世史\n            {\"q\": \"1543年、種子島に鉄砲を伝えた国はどこか？\", \"a\": [\"ポルトガル\", \"スペイン\", \"オランダ\", \"イギリス\"], \"c\": 0, \"type\": \"choice\"},\n            {\"q\": \"1549年、日本にキリスト教を伝えた宣教師は誰か？\", \"a\": [\"フランシスコ・ザビエル\", \"ルイス・フロイス\", \"オルガンティノ\", \"ヴァリニャーニ\"], \"c\": 0, \"type\": \"choice\"},\n            {\"q\": \"1582年の本能寺の変で織田信長を討った武将は誰か？（ひらがな）\", \"ans\": \"あけちみつひで\", \"type\": \"text\"},\n            {\"q\": \"豊臣秀吉が行った、全国の土地と石高を調査した政策は何か？\", \"a\": [\"太閤検地\", \"刀狩\", \"兵農分離\", \"朱印船貿易\"], \"c\": 0, \"type\": \"choice\"},\n            {\"q\": \"1600年、関ヶ原の戦いで西軍の総大将を務めたのは誰か？\", \"a\": [\"毛利輝元\", \"石田三成\", \"宇喜多秀家\", \"小西行長\"], \"c\": 0, \"type\": \"choice\"},\n            {\"q\": \"1637-38年の島原・天草一揆の指導者とされる人物は誰か？（ひらがな）\", \"ans\": \"あまくさしろう\", \"type\": \"text\"},\n            {\"q\": \"江戸時代、朝鮮通信使が将軍の代替わりごとに来日した際の名目は何か？\", \"a\": [\"通信\", \"朝貢\", \"交易\", \"親善\"], \"c\": 0, \"type\": \"choice\"},\n            {\"q\": \"江戸幕府が1639年に出した、ポルトガル船の来航を禁止した命令を何というか？\", \"a\": [\"鎖国令\", \"禁教令\", \"絵踏\", \"宗門改\"], \"c\": 0, \"type\": \"choice\"},\n            {\"q\": \"江戸時代、幕府が金・銀の含有量を減らして改鋳することを何というか？\", \"a\": [\"出目\", \"改鋳\", \"元文改鋳\", \"通貨収縮\"], \"c\": 0, \"type\": \"choice\"},\n            {\"q\": \"享保の改革を行った8代将軍は誰か？\", \"a\": [\"徳川吉宗\", \"徳川綱吉\", \"徳川家斉\", \"徳川家光\"], \"c\": 0, \"type\": \"choice\"},\n            {\"q\": \"田沼意次が奨励した、蝦夷地探検を行った人物は誰か？\", \"a\": [\"最上徳内\", \"間宮林蔵\", \"近藤重蔵\", \"伊能忠敬\"], \"c\": 0, \"type\": \"choice\"},\n            {\"q\": \"1825年に出された、外国船を無条件で打ち払う命令を何というか？\", \"a\": [\"異国船打払令\", \"海防令\", \"鎖国令\", \"薪水給与令\"], \"c\": 0, \"type\": \"choice\"},\n            {\"q\": \"1837年、大坂で乱を起こした元大坂町奉行所与力は誰か？（ひらがな）\", \"ans\": \"おおしおへいはちろう\", \"type\": \"text\"},\n            {\"q\": \"天保の改革を行った老中は誰か？\", \"a\": [\"水野忠邦\", \"松平定信\", \"田沼意次\", \"新井白石\"], \"c\": 0, \"type\": \"choice\"},\n            \n            # 幕末・明治維新\n            {\"q\": \"1853年、浦賀に来航したアメリカの提督は誰か？\", \"a\": [\"ペリー\", \"ハリス\", \"プチャーチン\", \"ビッドル\"], \"c\": 0, \"type\": \"choice\"},\n            {\"q\": \"1858年、日米修好通商条約に調印した大老は誰か？（ひらがな）\", \"ans\": \"いいなおすけ\", \"type\": \"text\"},\n            {\"q\": \"1858年の安政の大獄で処刑された、尊王攘夷派の中心人物は誰か？\", \"a\": [\"吉田松陰\", \"橋本左内\", \"頼三樹三郎\", \"梅田雲浜\"], \"c\": 0, \"type\": \"choice\"},\n            {\"q\": \"1867年、大政奉還を行った将軍は誰か？\", \"a\": [\"徳川慶喜\", \"徳川家茂\", \"徳川家定\", \"徳川斉昭\"], \"c\": 0, \"type\": \"choice\"},\n            {\"q\": \"1868年に発布された、天皇が政治の基本方針を示した文書は何か？\", \"a\": [\"五箇条の御誓文\", \"五榜の掲示\", \"学制\", \"教育勅語\"], \"c\": 0, \"type\": \"choice\"},\n            {\"q\": \"1871年の廃藩置県で、最初の知事に任命されたのは誰か？\", \"a\": [\"旧藩主\", \"中央派遣官僚\", \"郡県制の県令\", \"民選知事\"], \"c\": 1, \"type\": \"choice\"},\n            {\"q\": \"1873年に実施された、満20歳以上の男子に兵役を課す制度は何か？\", \"a\": [\"徴兵令\", \"学制\", \"地租改正\", \"廃藩置県\"], \"c\": 0, \"type\": \"choice\"},\n            {\"q\": \"1877年、西郷隆盛を中心に起こった士族の反乱は何か？\", \"a\": [\"西南戦争\", \"佐賀の乱\", \"秩父事件\", \"神風連の乱\"], \"c\": 0, \"type\": \"choice\"},\n            {\"q\": \"1877年の西南戦争で、政府軍の司令官を務めた人物は誰か？\", \"a\": [\"山県有朋\", \"大久保利通\", \"木戸孝允\", \"伊藤博文\"], \"c\": 0, \"type\": \"choice\"},\n            {\"q\": \"1889年、大日本帝国憲法の草案作成の中心となった人物は誰か？（ひらがな）\", \"ans\": \"いとうひろぶみ\", \"type\": \"text\"},\n            {\"q\": \"1889年に発布された、アジア初の近代憲法は何か？\", \"a\": [\"大日本帝国憲法\", \"日本国憲法\", \"十七条憲法\", \"御成敗式目\"], \"c\": 0, \"type\": \"choice\"},\n            {\"q\": \"1890年、第1回帝国議会で最大政党となったのはどこか？\", \"a\": [\"立憲自由党\", \"立憲改進党\", \"大成会\", \"国民協会\"], \"c\": 0, \"type\": \"choice\"},\n            \n            # 近代史\n            {\"q\": \"1894年、日本が開戦した戦争は何か？\", \"a\": [\"日清戦争\", \"日露戦争\", \"日中戦争\", \"太平洋戦争\"], \"c\": 0, \"type\": \"choice\"},\n            {\"q\": \"日清戦争の講和条約で清から獲得した賠償金は何両（テール）か？\", \"a\": [\"2億両\", \"3億両\", \"1億両\", \"5億両\"], \"c\": 0, \"type\": \"choice\"},\n            {\"q\": \"1902年、日本が締結した初の対等条約は何か？\", \"a\": [\"日英同盟\", \"日露協約\", \"日仏協約\", \"日米修好通商条約\"], \"c\": 0, \"type\": \"choice\"},\n            {\"q\": \"1904-1905年の日露戦争の講和条約は何か？\", \"a\": [\"ポーツマス条約\", \"下関条約\", \"樺太・千島交換条約\", \"日韓併合条約\"], \"c\": 0, \"type\": \"choice\"},\n            {\"q\": \"1911年、関税自主権の完全回復を達成した外務大臣は誰か？（ひらがな）\", \"ans\": \"こむらじゅたろう\", \"type\": \"text\"},\n            {\"q\": \"1918年の米騒動の発端となった地域はどこか？\", \"a\": [\"富山県\", \"新潟県\", \"大阪府\", \"東京府\"], \"c\": 0, \"type\": \"choice\"},\n            {\"q\": \"1925年に制定された、満25歳以上の男子に選挙権を与えた法律は何か？\", \"a\": [\"普通選挙法\", \"治安維持法\", \"国家総動員法\", \"大政翼賛会\"], \"c\": 0, \"type\": \"choice\"},\n            {\"q\": \"1931年、関東軍が起こした事変は何か？\", \"a\": [\"満州事変\", \"盧溝橋事件\", \"二・二六事件\", \"五・一五事件\"], \"c\": 0, \"type\": \"choice\"},\n            {\"q\": \"1945年8月6日、原子爆弾が投下された都市はどこか？\", \"a\": [\"広島\", \"長崎\", \"東京\", \"大阪\"], \"c\": 0, \"type\": \"choice\"},\n        ]\n    \n    def initialize_board(self):\n        \"\"\"盤面を初期化（中央に初期配置）\"\"\"\n        self.board[3][3] = self.WHITE\n        self.board[3][4] = self.BLACK\n        self.board[4][3] = self.BLACK\n        self.board[4][4] = self.WHITE\n    \n    def print_board(self):\n        \"\"\"盤面を表示\"\"\"\n        print(\"\\n  \", end=\"\")\n        for i in range(self.BOARD_SIZE):\n            print(f\" {i}\", end=\"\")\n        print()\n        \n        for i in range(self.BOARD_SIZE):\n            print(f\"{i} |\", end=\"\")\n            for j in range(self.BOARD_SIZE):\n                if self.board[i][j] == self.BLACK:\n                    print(\"●|\", end=\"\")\n                elif self.board[i][j] == self.WHITE:\n                    print(\"○|\", end=\"\")\n                else:\n                    print(\" |\", end=\"\")\n            print()\n        print()\n    \n    def ask_quiz(self):\n        \"\"\"\n        クイズを出題（選択式または記述式）\n        正解ならTrue、不正解ならFalseを返す\n        \"\"\"\n        quiz = random.choice(self.quiz_db)\n        print(\"\\n\" + \"=\"*60)\n        print(\"📚 日本史クイズチャレンジ！（早慶上智レベル）\")\n        print(\"=\"*60)\n        print(f\"\\n問題: {quiz['q']}\\n\")\n        \n        if quiz['type'] == 'choice':\n            # 選択式問題\n            for i, answer in enumerate(quiz['a']):\n                print(f\"{i+1}. {answer}\")\n            \n            while True:\n                try:\n                    user_answer = int(input(\"\\n答えを選んでください (1-4): \")) - 1\n                    if 0 <= user_answer < 4:\n                        if user_answer == quiz['c']:\n                            print(\"\\n🎉 正解！石を置けます！\")\n                            return True\n                        else:\n                            print(f\"\\n❌ 不正解！正解は「{quiz['a'][quiz['c']]}」でした\")\n                            print(\"ターンをスキップします...\")\n                            return False\n                except:\n                    print(\"1-4の数字を入力してください\")\n        \n        else:\n            # 記述式問題（ひらがな入力）\n            print(\"※答えはひらがなで入力してください\")\n            user_answer = input(\"\\n答え: \").strip()\n            \n            if user_answer == quiz['ans']:\n                print(\"\\n🎉 正解！石を置けます！\")\n                return True\n            else:\n                print(f\"\\n❌ 不正解！正解は「{quiz['ans']}」でした\")\n                print(\"ターンをスキップします...\")\n                return False\n    \n    def get_valid_moves(self, player):\n        \"\"\"有効な手をすべて取得\"\"\"\n        moves = []\n        for row in range(self.BOARD_SIZE):\n            for col in range(self.BOARD_SIZE):\n                if self.is_valid_move(row, col, player):\n                    moves.append((row, col))\n        return moves\n    \n    def is_valid_move(self, row, col, player):\n        \"\"\"指定位置に石を置けるかチェック\"\"\"\n        if self.board[row][col] != self.EMPTY:\n            return False\n        \n        directions = [(-1,-1), (-1,0), (-1,1), (0,-1), (0,1), (1,-1), (1,0), (1,1)]\n        \n        for dr, dc in directions:\n            if self.can_flip_in_direction(row, col, player, dr, dc):\n                return True\n        return False\n    \n    def can_flip_in_direction(self, row, col, player, dr, dc):\n        \"\"\"指定方向に石をひっくり返せるかチェック\"\"\"\n        opponent = self.WHITE if player == self.BLACK else self.BLACK\n        r, c = row + dr, col + dc\n        count = 0\n        \n        while 0 <= r < self.BOARD_SIZE and 0 <= c < self.BOARD_SIZE:\n            if self.board[r][c] == self.EMPTY:\n                return False\n            elif self.board[r][c] == opponent:\n                count += 1\n                r += dr\n                c += dc\n            elif self.board[r][c] == player:\n                return count > 0\n        return False\n    \n    def place_piece(self, row, col):\n        \"\"\"石を置く\"\"\"\n        if not self.is_valid_move(row, col, self.current_player):\n            return False\n        \n        self.board[row][col] = self.current_player\n        \n        # 全方向の石をひっくり返す\n        directions = [(-1,-1), (-1,0), (-1,1), (0,-1), (0,1), (1,-1), (1,0), (1,1)]\n        for dr, dc in directions:\n            self.flip_pieces(row, col, dr, dc)\n        \n        return True\n    \n    def flip_pieces(self, row, col, dr, dc):\n        \"\"\"指定方向の石をひっくり返す\"\"\"\n        player = self.current_player\n        opponent = self.WHITE if player == self.BLACK else self.BLACK\n        pieces_to_flip = []\n        r, c = row + dr, col + dc\n        \n        while 0 <= r < self.BOARD_SIZE and 0 <= c < self.BOARD_SIZE:\n            if self.board[r][c] == opponent:\n                pieces_to_flip.append((r, c))\n                r += dr\n                c += dc\n            elif self.board[r][c] == player:\n                for flip_r, flip_c in pieces_to_flip:\n                    self.board[flip_r][flip_c] = player\n                return\n            else:\n                return\n    \n    def get_scores(self):\n        \"\"\"スコアを取得\"\"\"\n        black_count = sum(row.count(self.BLACK) for row in self.board)\n        white_count = sum(row.count(self.WHITE) for row in self.board)\n        return black_count, white_count\n    \n    def is_game_over(self):\n        \"\"\"ゲーム終了判定\"\"\"\n        black_moves = self.get_valid_moves(self.BLACK)\n        white_moves = self.get_valid_moves(self.WHITE)\n        return len(black_moves) == 0 and len(white_moves) == 0\n    \n    def play(self):\n        \"\"\"ゲームをプレイ\"\"\"\n        print(\"=\"*60)\n        print(\"🎓 日本史クイズオセロ - 早慶上智レベル！\")\n        print(\"=\"*60)\n        print(\"\\n黒: ●  白: ○\")\n        print(\"【ルール】石を置く前にクイズに正解する必要があります！\")\n        print(\"正解: 石を置ける  不正解: ターンスキップ\\n\")\n        \n        while not self.is_game_over():\n            self.print_board()\n            black_score, white_score = self.get_scores()\n            print(f\"スコア - 黒: {black_score}, 白: {white_score}\")\n            \n            valid_moves = self.get_valid_moves(self.current_player)\n            \n            if len(valid_moves) == 0:\n                player_name = \"黒\" if self.current_player == self.BLACK else \"白\"\n                print(f\"\\n{player_name}はパスです\")\n                self.current_player = self.WHITE if self.current_player == self.BLACK else self.BLACK\n                continue\n            \n            player_name = \"黒\" if self.current_player == self.BLACK else \"白\"\n            print(f\"\\n{'='*60}\")\n            print(f\"{player_name}の番\")\n            print(f\"{'='*60}\")\n            print(f\"置ける場所: {valid_moves}\")\n            \n            # まずクイズに挑戦\n            if not self.ask_quiz():\n                # 不正解の場合はターンスキップ\n                self.current_player = self.WHITE if self.current_player == self.BLACK else self.BLACK\n                input(\"\\nEnterキーで続行...\")\n                continue\n            \n            # 正解したので石を置く\n            while True:\n                try:\n                    row = int(input(\"\\n行を入力 (0-7): \"))\n                    col = int(input(\"列を入力 (0-7): \"))\n                    \n                    if (row, col) in valid_moves:\n                        self.place_piece(row, col)\n                        break\n                    else:\n                        print(\"そこには置けません！\")\n                except:\n                    print(\"正しい数字を入力してください\")\n            \n            self.current_player = self.WHITE if self.current_player == self.BLACK else self.BLACK\n        \n        # ゲーム終了\n        self.print_board()\n        black_score, white_score = self.get_scores()\n        print(\"\\n\" + \"=\"*60)\n        print(\"🎉 ゲーム終了！\")\n        print(\"=\"*60)\n        print(f\"最終スコア - 黒: {black_score}, 白: {white_score}\\n\")\n        \n        if black_score > white_score:\n            print(\"🏆 黒の勝ち！\")\n        elif white_score > black_score:\n            print(\"🏆 白の勝ち！\")\n        else:\n            print(\"🤝 引き分け！\")\n\n# ========================================\n# ゲーム開始\n# ========================================\nif __name__ == \"__main__\":\n    game = QuizOthello()\n    game.play()"
  },
  {
    "name": "Yugo",
    "description": "本プログラムは、Google Colab 上で動作する CUI(文字ベース)のオセロゲームである。   第10回の講義で学習した「探索アルゴリズム」を用いて、盤面の中から合法手を探索するようにした。具体的には、for文による線形探索で盤面全体を調べ、石をひっくり返せるかを判定している。  また、第10回で学んだファイル入出力を利用し、各ターンの手や結果を /content/othello_log.txt に保存する機能を実装した。  工夫した点として、合法手がない場合は自動的にパスする処理を追加し、ゲームとして最後まで遊べるようにした。",
    "code": "# -*- coding: utf-8 -*-\n# Google Colab用 オセロ（リバーシ）\n# 第10回の内容：探索アルゴリズム（線形探索的処理）とファイル出力を利用\n\nimport numpy as np\n\n# =========================\n# 盤面の初期化\n# =========================\nEMPTY = '.'\nBLACK = 'B'\nWHITE = 'W'\n\nboard = [[EMPTY for _ in range(8)] for _ in range(8)]\n\n# 初期配置\nboard[3][3] = WHITE\nboard[3][4] = BLACK\nboard[4][3] = BLACK\nboard[4][4] = WHITE\n\ncurrent_player = BLACK\n\n# =========================\n# 盤面表示\n# =========================\ndef print_board():\n    print(\"  0 1 2 3 4 5 6 7\")\n    for i in range(8):\n        print(i, end=\" \")\n        for j in range(8):\n            print(board[i][j], end=\" \")\n        print()\n    print()\n\n# =========================\n# 探索処理（第10回内容）\n# =========================\ndef can_flip(x, y, dx, dy, player):\n    enemy = WHITE if player == BLACK else BLACK\n    nx, ny = x + dx, y + dy\n\n    found_enemy = False\n    while 0 <= nx < 8 and 0 <= ny < 8:\n        if board[nx][ny] == enemy:\n            found_enemy = True\n        elif board[nx][ny] == player:\n            return found_enemy\n        else:\n            break\n        nx += dx\n        ny += dy\n    return False\n\ndef is_valid_move(x, y, player):\n    if board[x][y] != EMPTY:\n        return False\n    for dx in [-1,0,1]:\n        for dy in [-1,0,1]:\n            if dx == 0 and dy == 0:\n                continue\n            if can_flip(x, y, dx, dy, player):\n                return True\n    return False\n\ndef flip_discs(x, y, player):\n    enemy = WHITE if player == BLACK else BLACK\n    board[x][y] = player\n\n    for dx in [-1,0,1]:\n        for dy in [-1,0,1]:\n            if dx == 0 and dy == 0:\n                continue\n            if can_flip(x, y, dx, dy, player):\n                nx, ny = x + dx, y + dy\n                while board[nx][ny] == enemy:\n                    board[nx][ny] = player\n                    nx += dx\n                    ny += dy\n\n# =========================\n# 合法手の探索（線形探索）\n# =========================\ndef get_valid_moves(player):\n    moves = []\n    for i in range(8):\n        for j in range(8):\n            if is_valid_move(i, j, player):\n                moves.append((i, j))\n    return moves\n\n# =========================\n# 石の数を数える\n# =========================\ndef count_discs():\n    b = 0\n    w = 0\n    for row in board:\n        for c in row:\n            if c == BLACK:\n                b += 1\n            elif c == WHITE:\n                w += 1\n    return b, w\n\n# =========================\n# ログをファイルに書く（第10回内容）\n# =========================\nlog_path = \"/content/othello_log.txt\"\nlog_file = open(log_path, \"w\")\n\ndef write_log(text):\n    log_file.write(text + \"\\n\")\n    log_file.flush()\n\n# =========================\n# メインループ\n# =========================\nturn = 1\nwhile True:\n    print_board()\n    print(f\"ターン {turn} : プレイヤー {current_player}\")\n    write_log(f\"Turn {turn} Player {current_player}\")\n\n    valid_moves = get_valid_moves(current_player)\n\n    # 手がない場合はパス\n    if len(valid_moves) == 0:\n        print(\"打てる場所がないのでパスします\")\n        write_log(\"pass\")\n\n        # 両者パスなら終了\n        other = WHITE if current_player == BLACK else BLACK\n        if len(get_valid_moves(other)) == 0:\n            break\n\n        current_player = other\n        continue\n\n    print(\"打てる場所:\", valid_moves)\n\n    # 入力\n    move = input(\"x y の形式で入力してください（例: 2 3）: \")\n    if move == \"q\":\n        break\n\n    try:\n        x, y = map(int, move.split())\n    except:\n        print(\"入力形式が間違っています\")\n        continue\n\n    if not is_valid_move(x, y, current_player):\n        print(\"そこには置けません\")\n        continue\n\n    flip_discs(x, y, current_player)\n\n    # 手をログに保存\n    write_log(f\"move: {x} {y}\")\n\n    # プレイヤー交代\n    current_player = WHITE if current_player == BLACK else BLACK\n    turn += 1\n\n# =========================\n# 終了処理\n# =========================\nprint_board()\nblack_count, white_count = count_discs()\n\nprint(f\"黒: {black_count}  白: {white_count}\")\nwrite_log(f\"Result B:{black_count} W:{white_count}\")\n\nlog_file.close()\nprint(f\"対局ログを {log_path} に保存しました\")\n"
  },
  {
    "name": "Mihane",
    "description": "〇と●を使って、実際のオセロに見た目を近づけました。全部〇もしくは全部●になったときに特別なメッセージが出るように工夫しました。",
    "code": "def create_board():\n    board = [[\"・\" for _ in range(8)] for _ in range(8)]\n    board[3][3] = \"〇\"\n    board[3][4] = \"●\"\n    board[4][3] = \"●\"\n    board[4][4] = \"〇\"\n    return board\n\ndef print_board(board):\n    print(\"   ０ １ ２ ３ ４ ５ ６ ７\")\n    for i, row in enumerate(board):\n        print(\"０１２３４５６７\"[i], \" \".join(row))\n\ndef flip_all(board, r, c, turn):\n    opponent = \"●\" if turn == \"〇\" else \"〇\"\n\n    directions = [\n        (-1, 0), (1, 0), (0, -1), (0, 1),\n        (-1, -1), (-1, 1), (1, -1), (1, 1)\n    ]\n\n    for dr, dc in directions:\n        stones_to_flip = []\n        x = r + dr\n        y = c + dc\n\n        while 0 <= x < 8 and 0 <= y < 8 and board[x][y] == opponent:\n            stones_to_flip.append((x, y))\n            x += dr\n            y += dc\n\n        if 0 <= x < 8 and 0 <= y < 8 and board[x][y] == turn:\n            for rr, cc in stones_to_flip:\n                board[rr][cc] = turn\n\ndef can_place(board, r, c, turn):\n    if board[r][c] != \"・\":\n        return False\n\n    opponent = \"●\" if turn == \"〇\" else \"〇\"\n\n    directions = [\n        (-1, 0), (1, 0), (0, -1), (0, 1),\n        (-1, -1), (-1, 1), (1, -1), (1, 1)\n    ]\n\n    for dr, dc in directions:\n        x = r + dr\n        y = c + dc\n        found_opponent = False\n\n        while 0 <= x < 8 and 0 <= y < 8 and board[x][y] == opponent:\n            found_opponent = True\n            x += dr\n            y += dc\n\n        if found_opponent and 0 <= x < 8 and 0 <= y < 8 and board[x][y] == turn:\n            return True\n\n    return False\n\ndef count_stones(board):\n    b = sum(row.count(\"●\") for row in board)\n    w = sum(row.count(\"〇\") for row in board)\n    return b, w\n\nboard = create_board()\nturn = \"●\"\n\nwhile True:\n    print_board(board)\n    print(\"現在の手番:\", turn)\n\n    moves = [(r, c) for r in range(8) for c in range(8) if can_place(board, r, c, turn)]\n\n    if not moves:\n        print(\"置ける場所がないのでパスします\")\n        turn = \"〇\" if turn == \"●\" else \"●\"\n        moves2 = [(r, c) for r in range(8) for c in range(8) if can_place(board, r, c, turn)]\n        if not moves2:\n            print(\"両プレイヤーとも置けません。終了します\")\n            break\n        continue\n\n    r = int(input(\"行番号: \"))\n    c = int(input(\"列番号: \"))\n\n    if not (0 <= r < 8 and 0 <= c < 8):\n        print(\"範囲外です\")\n        continue\n    if not can_place(board, r, c, turn):\n        print(\"そこには置けません😿\")\n        continue\n\n    board[r][c] = turn\n    flip_all(board, r, c, turn)\n    turn = \"〇\" if turn == \"●\" else \"●\"\n\nb, w = count_stones(board)\nprint(\"最終結果\")\nprint(\"●:\", b, \" 〇:\", w)\n\nif b == 64:\n    print(\"盤面がすべて●になりました。完全勝利です！おめでとう！🎉\")\nelif w == 64:\n    print(\"盤面がすべて〇になりました。素晴らしい！お見事です！👏\")\nelif b > w:\n    print(\"● の勝ち！\")\nelif w > b:\n    print(\"〇 の勝ち！\")\nelse:\n    print(\"引き分け🐱\")"
  },
  {
    "name": "Kousei",
    "description": "このプログラムは Google Colab 上で動作するオセロゲームで、matplotlib による描画とクリック操作による入力を組み合わせています。合法手は黄色のガイド表示でわかりやすく示され、石を置くと反転処理が実行されます。また、簡易的な CPU(ランダムAI)との対戦モードも実装しており、コードを拡張しやすい構造になっています。コマンドライン型ではなく、ノートブック上でインタラクティブに遊べる点が独創的です。",
    "code": "# ===============================\n# Google Colab版 オセロゲーム\n# Matplotlib クリック操作対応\n# ===============================\n\nimport numpy as np\nimport matplotlib.pyplot as plt\nfrom matplotlib.patches import Circle\n\nBOARD_SIZE = 8\n\n# 初期盤面の作成\ndef init_board():\n    board = np.zeros((BOARD_SIZE, BOARD_SIZE), dtype=int)\n    board[3,3] = board[4,4] = 2  # 白\n    board[3,4] = board[4,3] = 1  # 黒\n    return board\n\n# 8方向\nDIRECTIONS = [\n    (-1,0),(1,0),(0,-1),(0,1),\n    (-1,-1),(-1,1),(1,-1),(1,1)\n]\n\n# その手が合法か判定し、返せる石の座標リストを返す\ndef get_flips(board, row, col, player):\n    if board[row,col] != 0:\n        return []\n\n    opponent = 2 if player == 1 else 1\n    flips = []\n\n    for dr,dc in DIRECTIONS:\n        r, c = row + dr, col + dc\n        line = []\n\n        while 0 <= r < BOARD_SIZE and 0 <= c < BOARD_SIZE:\n            if board[r,c] == opponent:\n                line.append((r,c))\n            elif board[r,c] == player:\n                if len(line) > 0:\n                    flips.extend(line)\n                break\n            else:\n                break\n            r += dr\n            c += dc\n\n    return flips\n\n# 合法手一覧\ndef get_valid_moves(board, player):\n    moves = []\n    for r in range(BOARD_SIZE):\n        for c in range(BOARD_SIZE):\n            if len(get_flips(board, r, c, player)) > 0:\n                moves.append((r,c))\n    return moves\n\n# 石を置く\ndef place_disk(board, row, col, player):\n    flips = get_flips(board, row, col, player)\n    if len(flips) == 0:\n        return False\n    board[row,col] = player\n    for r,c in flips:\n        board[r,c] = player\n    return True\n\n# CPU（ランダムAI）\ndef cpu_move(board, player):\n    moves = get_valid_moves(board, player)\n    if not moves:\n        return None\n    return moves[np.random.randint(len(moves))]\n\n# 描画\ndef draw_board(board, valid_moves=None):\n    plt.clf()\n    plt.imshow(np.zeros_like(board), cmap=\"Greens\", vmin=0, vmax=1)\n\n    ax = plt.gca()\n    ax.set_xticks(np.arange(-.5, BOARD_SIZE, 1))\n    ax.set_yticks(np.arange(-.5, BOARD_SIZE, 1))\n    ax.set_xticklabels([])\n    ax.set_yticklabels([])\n    plt.grid(color=\"black\")\n\n    for r in range(BOARD_SIZE):\n        for c in range(BOARD_SIZE):\n            if board[r,c] == 1:\n                ax.add_patch(Circle((c, r), 0.4, color=\"black\"))\n            elif board[r,c] == 2:\n                ax.add_patch(Circle((c, r), 0.4, color=\"white\"))\n\n    # 合法手のハイライト\n    if valid_moves:\n        for r,c in valid_moves:\n            ax.add_patch(Circle((c, r), 0.15, color=\"yellow\"))\n\n    plt.title(f\"Player {current_player}'s turn\")\n    plt.pause(0.01)\n\n# === メインゲーム ===\n\nboard = init_board()\ncurrent_player = 1  # 黒から\n\nfig = plt.figure(figsize=(6,6))\ndraw_board(board, get_valid_moves(board, current_player))\n\ndef on_click(event):\n    global current_player, board\n\n    if event.xdata is None or event.ydata is None:\n        return\n\n    col = int(event.xdata + 0.5)\n    row = int(event.ydata + 0.5)\n\n    valid = get_valid_moves(board, current_player)\n    if (row,col) in valid:\n        place_disk(board, row, col, current_player)\n\n        # 相手番へ\n        current_player = 2 if current_player == 1 else 1\n\n        # CPU対戦モード（必要ならON）\n        # if current_player == 2:\n        #     move = cpu_move(board,2)\n        #     if move:\n        #         place_disk(board, move[0], move[1], 2)\n        #     current_player = 1\n\n        draw_board(board, get_valid_moves(board, current_player))\n\ncid = fig.canvas.mpl_connect(\"button_press_event\", on_click)\nplt.show()"
  },
  {
    "name": "Jinichi",
    "description": "このプログラムでは、対人対戦ができるようにした点や、コマの表記を簡単に変更できるようにした点、マス目を表記しておく場所を見やすくした点などで工夫しました。",
    "code": "# ====== オセロ（リバーシ）対人戦 Google Colab版 ======\n\n# --- 好きな文字に変更できるコマ表記 ---\nBLACK = \"●\"   # 黒コマ\nWHITE = \"〇\"   # 白コマ\nEMPTY = \"・\"   # 空マス\n\n# --- ボードサイズ ---\nBOARD_SIZE = 8\n\n# --- 盤の作成 ---\ndef create_board():\n    board = [[EMPTY for _ in range(BOARD_SIZE)] for _ in range(BOARD_SIZE)]\n    mid = BOARD_SIZE // 2\n    board[mid - 1][mid - 1] = WHITE\n    board[mid][mid] = WHITE\n    board[mid - 1][mid] = BLACK\n    board[mid][mid - 1] = BLACK\n    return board\n\n# --- 盤面表示 ---\ndef print_board(board):\n    # 列番号表示（位置ずれ修正）\n    print(\"    \" + \"  \".join(str(i+1) for i in range(BOARD_SIZE)))\n    print(\"  +\" + \"---\"*BOARD_SIZE + \"+\")\n    \n    for i, row in enumerate(board):\n        row_letter = chr(ord(\"A\") + i)\n        print(f\"{row_letter} | \" + \" \".join(row) + \" |\")\n    \n    print(\"  +\" + \"---\"*BOARD_SIZE + \"+\")\n\n# --- 挟める方向を調査するための8方向 ---\nDIRECTIONS = [(-1,-1),(-1,0),(-1,1),\n              (0,-1),       (0,1),\n              (1,-1),(1,0),(1,1)]\n\n# --- 指定手が合法か判定 ---\ndef is_valid_move(board, row, col, player):\n    if board[row][col] != EMPTY:\n        return False\n\n    opponent = WHITE if player == BLACK else BLACK\n    valid = False\n\n    for dr, dc in DIRECTIONS:\n        r, c = row + dr, col + dc\n        count_opponent = 0\n\n        while 0 <= r < BOARD_SIZE and 0 <= c < BOARD_SIZE and board[r][c] == opponent:\n            count_opponent += 1\n            r += dr\n            c += dc\n\n        if count_opponent > 0 and 0 <= r < BOARD_SIZE and 0 <= c < BOARD_SIZE and board[r][c] == player:\n            valid = True\n\n    return valid\n\n\n# --- 石をひっくり返す ---\ndef apply_move(board, row, col, player):\n    opponent = WHITE if player == BLACK else BLACK\n    board[row][col] = player\n    for dr, dc in DIRECTIONS:\n        r, c = row + dr, col + dc\n        stones = []\n        while 0 <= r < BOARD_SIZE and 0 <= c < BOARD_SIZE and board[r][c] == opponent:\n            stones.append((r,c))\n            r += dr\n            c += dc\n        if stones and 0 <= r < BOARD_SIZE and 0 <= c < BOARD_SIZE and board[r][c] == player:\n            for rr, cc in stones:\n                board[rr][cc] = player\n\n\n# --- プレイ可能手を探す ---\ndef valid_moves(board, player):\n    moves = []\n    for r in range(BOARD_SIZE):\n        for c in range(BOARD_SIZE):\n            if is_valid_move(board, r, c, player):\n                moves.append((r,c))\n    return moves\n\n\n# --- ゲーム進行 ---\ndef play_game():\n    board = create_board()\n    current_player = BLACK\n\n    while True:\n        print_board(board)\n        moves = valid_moves(board, current_player)\n\n        if not moves:\n            print(f\"{current_player} は置ける場所がありません。パスします。\")\n            current_player = WHITE if current_player == BLACK else BLACK\n            if not valid_moves(board, current_player):\n                print(\"両者置ける場所がありません。ゲーム終了。\")\n                break\n            continue\n\n        print(f\"{current_player} の番です。 例: A1, D5\")\n        user_input = input(\"場所を入力してください: \").strip().upper()\n\n        if len(user_input) < 2:\n            print(\"入力形式が違います。\")\n            continue\n\n        row = ord(user_input[0]) - ord(\"A\")\n        col = int(user_input[1:]) - 1\n\n        if (row, col) not in moves:\n            print(\"そこには置けません。\")\n            continue\n\n        apply_move(board, row, col, current_player)\n        current_player = WHITE if current_player == BLACK else BLACK\n\n    # --- 結果集計 ---\n    black_count = sum(row.count(BLACK) for row in board)\n    white_count = sum(row.count(WHITE) for row in board)\n    print_board(board)\n    print(\"結果\")\n    print(f\"{BLACK}: {black_count}\")\n    print(f\"{WHITE}: {white_count}\")\n    if black_count > white_count:\n        print(\"黒の勝ち!\")\n    elif white_count > black_count:\n        print(\"白の勝ち!\")\n    else:\n        print(\"引き分け!\")\n\n\nplay_game()\n"
  },
  {
    "name": "Souki",
    "description": "create_board():初期盤面の作成  valid_moves():合法手判定  make_move():石を裏返す処理  computer_move():コンピュータの手(ランダム → 強化可能)  メインループ:人間(黒)とコンピュータ(白)による対戦",
    "code": "# ==============================\n# シンプルなオセロ（リバーシ）CLI版\n# Google Colabで動作確認済み\n# 人間 vs コンピュータ（ランダム手）\n# ==============================\n\nimport random\nimport copy\n\n# 盤面の方向（8方向）\nDIRECTIONS = [\n    (-1, -1), (-1, 0), (-1, 1),\n    (0, -1),          (0, 1),\n    (1, -1),  (1, 0), (1, 1)\n]\n\ndef create_board():\n    \"\"\"初期盤面を作成\"\"\"\n    board = [[\".\" for _ in range(8)] for _ in range(8)]\n    board[3][3] = \"W\"\n    board[3][4] = \"B\"\n    board[4][3] = \"B\"\n    board[4][4] = \"W\"\n    return board\n\ndef print_board(board):\n    \"\"\"盤面表示\"\"\"\n    print(\"  A B C D E F G H\")\n    for i in range(8):\n        row = str(i+1) + \" \"\n        for j in range(8):\n            row += board[i][j] + \" \"\n        print(row)\n    print()\n\ndef is_on_board(x, y):\n    return 0 <= x < 8 and 0 <= y < 8\n\ndef valid_moves(board, player):\n    \"\"\"player の合法手を返す\"\"\"\n    opponent = \"W\" if player == \"B\" else \"B\"\n    moves = []\n\n    for x in range(8):\n        for y in range(8):\n            if board[x][y] != \".\":\n                continue\n\n            flips = []\n            for dx, dy in DIRECTIONS:\n                nx, ny = x + dx, y + dy\n                temp_flips = []\n\n                while is_on_board(nx, ny) and board[nx][ny] == opponent:\n                    temp_flips.append((nx, ny))\n                    nx += dx\n                    ny += dy\n\n                if is_on_board(nx, ny) and board[nx][ny] == player and temp_flips:\n                    flips.extend(temp_flips)\n\n            if flips:\n                moves.append((x, y))\n\n    return moves\n\ndef make_move(board, player, move):\n    \"\"\"player が move を打って盤面更新\"\"\"\n    x, y = move\n    board[x][y] = player\n    opponent = \"W\" if player == \"B\" else \"B\"\n\n    for dx, dy in DIRECTIONS:\n        nx, ny = x + dx, y + dy\n        flips = []\n\n        while is_on_board(nx, ny) and board[nx][ny] == opponent:\n            flips.append((nx, ny))\n            nx += dx\n            ny += dy\n\n        if is_on_board(nx, ny) and board[nx][ny] == player:\n            for fx, fy in flips:\n                board[fx][fy] = player\n\ndef count_stones(board):\n    \"\"\"石の数をカウント\"\"\"\n    blacks = sum(row.count(\"B\") for row in board)\n    whites = sum(row.count(\"W\") for row in board)\n    return blacks, whites\n\ndef computer_move(moves):\n    \"\"\"ランダム手（後で強化しやすい）\"\"\"\n    return random.choice(moves)\n\n# ==============================\n# メインループ（ゲーム進行）\n# ==============================\n\nboard = create_board()\nplayer = \"B\"  # 人間＝黒（先手）\n\nprint(\"===== オセロ開始！ =====\")\nprint(\"あなたは B（黒）です\")\nprint_board(board)\n\nwhile True:\n    moves = valid_moves(board, player)\n\n    if not moves:\n        print(f\"{player} は合法手が無いのでパス\")\n        player = \"W\" if player == \"B\" else \"B\"\n        if not valid_moves(board, player):\n            print(\"どちらも置けないので終了！\")\n            break\n        continue\n\n    if player == \"B\":\n        # -----------------------\n        # 人間の手\n        # -----------------------\n        print(\"あなた（B）の番です\")\n        print(\"合法手：\", [(x+1, chr(y+65)) for x, y in moves])\n\n        while True:\n            move_str = input(\"手を入力（例: 3C）：\").strip().upper()\n            if len(move_str) < 2:\n                print(\"形式が違います\")\n                continue\n            try:\n                x = int(move_str[0]) - 1\n                y = ord(move_str[1]) - 65\n                if (x, y) in moves:\n                    move = (x, y)\n                    break\n                else:\n                    print(\"その場所には置けません\")\n            except:\n                print(\"正しい形式で入力してください\")\n        print(f\"あなたの手：{move_str}\")\n\n    else:\n        # -----------------------\n        # コンピュータ（白）\n        # -----------------------\n        move = computer_move(moves)\n        print(f\"コンピュータ（W）の手：{move[0]+1}{chr(move[1]+65)}\")\n\n    make_move(board, player, move)\n    print_board(board)\n\n    # ターン交代\n    player = \"W\" if player == \"B\" else \"B\"\n\n# ==============================\n# 結果表示\n# ==============================\nblack, white = count_stones(board)\nprint(\"===== 結果 =====\")\nprint(\"黒(B)：\", black)\nprint(\"白(W)：\", white)\n\nif black > white:\n    print(\"あなたの勝ち！\")\nelif white > black:\n    print(\"コンピュータの勝ち！\")\nelse:\n    print(\"引き分け！\")\n"
  },
  {
    "name": "Aoi",
    "description": "このプログラムは、Google Colab 上で動作するオセロ(リバーシ)ゲームです。 8×8 の盤面をリストで管理し、黒石・白石・空白をそれぞれ \"B\"、\"W\"、\".\" で表しています。  プレイヤーが行番号と列番号を入力して石を置くと、オセロのルールに従って相手の石を自動で反転します。 合法手がない場合はパスし、両プレイヤーが連続してパスするとゲームが終了します。  Colab で確実に動くように、関数を分けて処理を分かりやすくし、ロジックが理解しやすい構成にしています。",
    "code": "# === オセロ（リバーシ）ゲーム ===\n# Google Colabで動作確認済み\n# 人間 vs 人間 で遊べる簡易版\n\n# 盤面サイズ\nSIZE = 8\n\n# 石の表現\nEMPTY = \".\"\nBLACK = \"B\"\nWHITE = \"W\"\n\n\n# 盤面を初期化\ndef init_board():\n    board = [[EMPTY for _ in range(SIZE)] for _ in range(SIZE)]\n\n    mid = SIZE // 2\n    board[mid-1][mid-1] = WHITE\n    board[mid][mid] = WHITE\n    board[mid-1][mid] = BLACK\n    board[mid][mid-1] = BLACK\n\n    return board\n\n\n# 盤面を表示\ndef print_board(board):\n    print(\"  \" + \" \".join(str(i) for i in range(SIZE)))\n    for i, row in enumerate(board):\n        print(i, \" \".join(row))\n    print()\n\n\n# 方向ベクトル（8方向）\nDIRECTIONS = [\n    (-1, -1), (-1, 0), (-1, 1),\n    (0, -1),          (0, 1),\n    (1, -1),  (1, 0), (1, 1)\n]\n\n\n# 合法手を取得\ndef get_valid_moves(board, player):\n    opponent = BLACK if player == WHITE else WHITE\n    moves = []\n\n    for r in range(SIZE):\n        for c in range(SIZE):\n            if board[r][c] != EMPTY:\n                continue\n\n            flips_total = []\n\n            # 8方向をチェック\n            for dr, dc in DIRECTIONS:\n                r2, c2 = r + dr, c + dc\n                flips = []\n\n                # 相手の石を探す\n                while 0 <= r2 < SIZE and 0 <= c2 < SIZE and board[r2][c2] == opponent:\n                    flips.append((r2, c2))\n                    r2 += dr\n                    c2 += dc\n\n                # その先に自分の石があれば合法\n                if flips and 0 <= r2 < SIZE and 0 <= c2 < SIZE and board[r2][c2] == player:\n                    flips_total += flips\n\n            if flips_total:\n                moves.append((r, c))\n\n    return moves\n\n\n# 石を置く + 反転する\ndef apply_move(board, player, move):\n    r, c = move\n    opponent = BLACK if player == WHITE else WHITE\n    board[r][c] = player\n\n    # 8方向をチェック\n    for dr, dc in DIRECTIONS:\n        r2, c2 = r + dr, c + dc\n        flips = []\n\n        while 0 <= r2 < SIZE and 0 <= c2 < SIZE and board[r2][c2] == opponent:\n            flips.append((r2, c2))\n            r2 += dr\n            c2 += dc\n\n        if flips and 0 <= r2 < SIZE and 0 <= c2 < SIZE and board[r2][c2] == player:\n            # 挟んでいた石を反転\n            for fr, fc in flips:\n                board[fr][fc] = player\n\n\n# メインゲームループ\ndef play_game():\n    board = init_board()\n    player = BLACK  # 先手は黒\n\n    while True:\n        print_board(board)\n        moves = get_valid_moves(board, player)\n\n        if not moves:\n            print(f\"{player} の合法手がありません。パスします。\")\n            player = WHITE if player == BLACK else BLACK\n            moves = get_valid_moves(board, player)\n\n            # 両者パスなら終了\n            if not moves:\n                print(\"両者とも手がありません。ゲーム終了！\")\n                break\n\n        print(f\"{player} の番です。合法手: {moves}\")\n        r = int(input(\"行を入力: \"))\n        c = int(input(\"列を入力: \"))\n\n        if (r, c) not in moves:\n            print(\"その手は打てません。やり直してください。\\n\")\n            continue\n\n        apply_move(board, player, (r, c))\n        player = WHITE if player == BLACK else BLACK\n\n    # 結果表示\n    black_count = sum(row.count(BLACK) for row in board)\n    white_count = sum(row.count(WHITE) for row in board)\n\n    print_board(board)\n    print(\"=== 結果 ===\")\n    print(f\"Black: {black_count}, White: {white_count}\")\n    if black_count > white_count:\n        print(\"Black の勝ち！\")\n    elif white_count > black_count:\n        print(\"White の勝ち！\")\n    else:\n        print(\"引き分け\")\n\n\n# ゲーム開始\nplay_game()\n"
  },
  {
    "name": "Takahiro",
    "description": "ルールとしては、プレイヤーが交互に行と列の数字を入力すると、そこに対応した枠に自分の駒を置くことができる。自身の駒で挟んだ場合にしっかりひっくり返るように設定した。オセロの黒と白を1と2数字に変換をして定義した。また、オセロのルールにある盤面で置ける手がなくなった時にカウントし一定回数に達したらゲームを終了できるように設定して工夫した。",
    "code": "def create_board():\n    \"\"\"8x8の盤面を作成し、初期の石を配置する。\"\"\"\n    # 8x8の二次元リストを作成し、全て空（0）で埋める\n    board = [[0 for _ in range(8)] for _ in range(8)]\n\n    # 初期配置\n    # 中央の4マスに白黒を交互に置く\n    board[3][3] = 2  # 白 \n    board[3][4] = 1  # 黒 \n    board[4][3] = 1  # 黒\n    board[4][4] = 2  # 白\n\n    return board\n\n\n# 盤面の表示\ndef print_board(board):\n    \"\"\"盤面をコンソールに表示する。\"\"\"\n\n    # 盤面の列番号（0から7）を表示\n    print(\"  0 1 2 3 4 5 6 7\")\n\n    # for文で各行を処理\n    for r in range(8):\n        # 行番号と区切り線を表示\n        line = f\"{r} \"\n\n        # 内側のfor文で各列を処理\n        for c in range(8):\n            cell = board[r][c]\n            if cell == 1:\n                line += \"● \"  # 黒\n            elif cell == 2:\n                line += \"○ \"  # 白\n            else:\n                line += \"□ \"  # 空\n        print(line)\n\n\nDIRECTIONS = [\n    (0, 1),   # 右\n    (0, -1),  # 左\n    (1, 0),   # 下\n    (-1, 0),  # 上\n    (1, 1),   # 右下\n    (1, -1),  # 左下\n    (-1, 1),  # 右上\n    (-1, -1)  # 左上\n]\n\ndef check_direction(board, row, col, player, dr, dc):\n    \"\"\"\n    (row, col)から(dr, dc)方向に、相手の石を挟んでいるかをチェックし、\n    挟んでいる場合はひっくり返す石のリストを返す。\n    \"\"\"\n\n    # 相手のプレイヤー番号を設定\n    opponent = 3 - player # 1なら2, 2なら1になる\n\n    r, c = row + dr, col + dc\n    stones_to_flip = [] # ひっくり返す石の座標を格納するリスト\n\n    # while文で盤面の端または空きマスに当たるまで進む\n    while 0 <= r < 8 and 0 <= c < 8 and board[r][c] == opponent:\n        stones_to_flip.append((r, c))\n        r += dr\n        c += dc\n\n    # 相手の石が1つ以上あり、その先に自分の石がある（挟めている）場合のみ、リストを返す\n    if stones_to_flip and 0 <= r < 8 and 0 <= c < 8 and board[r][c] == player:\n        return stones_to_flip\n    else:\n        return []\n\n\n# 有効な手かどうかの判定\ndef is_valid_move(board, row, col, player):\n    \"\"\"(row, col)にplayerの石が置けるか判定する。\"\"\"\n\n    # 既に石が置かれている、または盤面の範囲外なら無効\n    if not (0 <= row < 8 and 0 <= col < 8) or board[row][col] != 0:\n        return False\n\n    # 8方向すべてをチェックし、1つでもひっくり返せる石があれば有効な手\n    for dr, dc in DIRECTIONS:\n        if check_direction(board, row, col, player, dr, dc):\n            return True\n\n    return False\n\n\n# 石を置き、ひっくり返す\ndef make_move(board, row, col, player):\n    \"\"\"実際に石を置き、ひっくり返す処理を行う。\"\"\"\n\n    if not is_valid_move(board, row, col, player):\n        return False\n\n    board[row][col] = player\n\n    total_flipped = []\n\n    for dr, dc in DIRECTIONS:\n        flipped = check_direction(board, row, col, player, dr, dc)\n        if flipped:\n            total_flipped.extend(flipped)\n\n    # 集めたひっくり返す石の座標を使って、実際に石をひっくり返す\n    for r, c in total_flipped:\n        board[r][c] = player # 自分の石の色に変更\n\n    return True\n\n\n# 置ける場所があるかどうかの判定\ndef has_valid_move(board, player):\n    \"\"\"playerが石を置ける場所が残っているか判定する。\"\"\"\n\n    # 盤面の全マスを二重ループでチェック\n    for r in range(8):\n        for c in range(8):\n            if is_valid_move(board, r, c, player):\n                return True\n\n    return False\n\n\n# ゲームメインループ\ndef game_loop():\n    \"\"\"オセロゲームのメインの処理を行う。\"\"\"\n\n    # 盤面の初期化\n    board = create_board()\n\n    # プレイヤー1:黒(●), プレイヤー2:白(○)\n    current_player = 1\n\n    # 無効な手が連続した回数（2になったらゲーム終了）\n    passes_in_a_row = 0\n\n    # while文でゲームを進行\n    # passes_in_a_rowが2になる、または盤面に空きマスがなくなるまで続ける\n    while passes_in_a_row < 2:\n        print_board(board)\n\n        # プレイヤーの表示\n        player_symbol = \"● (黒)\" if current_player == 1 else \"○ (白)\"\n        print(f\"\\n現在のプレイヤー: {player_symbol}\")\n\n        # 置ける場所があるか判定\n        if has_valid_move(board, current_player):\n            passes_in_a_row = 0 # 置ける手があるのでパス回数をリセット\n\n            while True:\n                try:\n                    # ユーザーからの入力を受け取る\n                    \n                    move_str = input(\"行,列 をコンマ区切りで入力してください (例: 2,3): \")\n                    row, col = map(int, move_str.split(','))\n\n                    \n                    if make_move(board, row, col, current_player):\n                        break \n                    else:\n                        print(\"その場所には置けません。\")\n\n                except ValueError: \n                    print(\"入力形式が不正です。行と列をコンマ区切りで整数で入力してください。\")\n                except IndexError:\n                    print(\"入力形式が不正です。行と列の2つの値を入力してください。\")\n\n        else:\n            print(\"パスします。置ける場所がありません。\")\n            passes_in_a_row += 1\n\n        # プレイヤーの交代\n        current_player = 3 - current_player # 1 -> 2, 2 -> 1\n\n        # 盤面に空きマスがない場合もループを抜ける\n        if all(0 not in row for row in board):\n             print(\"盤面が全て埋まりました。ゲーム終了です。\")\n             break\n\n    # 最終的な盤面の表示と勝敗判定\n    print_board(board)\n    print(\"ゲーム終了\")\n\n    # 各プレイヤーの石の数をカウント\n    # 二重ループを使って盤面全体を数える\n    black_count = sum(row.count(1) for row in board)\n    white_count = sum(row.count(2) for row in board)\n\n    print(f\"● (黒) の数: {black_count}\")\n    print(f\"○ (白) の数: {white_count}\")\n\n    if black_count > white_count:\n        print(\"黒の勝ちです！\")\n    elif white_count > black_count:\n        print(\"白の勝ちです！\")\n    else:\n        print(\"引き分けです。\")\n\n\n# ゲームの実行\nif __name__ == \"__main__\":\n    game_loop()"
  },
  {
    "name": "XU",
    "description": "このプログラムは、8×8 のオセロ盤をリスト(2次元配列)で管理し、コンソール上でプレイできるオセロゲームです。 init_board で初期盤面を作成し、get_valid_moves と get_flips によって各手番で打てる場所と、ひっくり返る石を計算しています。 盤面の表示は print_board で行い、行・列番号を表示することで、ユーザーが「行 列」の形で入力しやすくしました。 また、対戦モードとして「人間 vs 人間」と「人間 vs コンピューター」を選べます。コンピューターは choose_ai_move によって「ひっくり返す枚数が最も多い手」を自動的に選ぶ、シンプルなAIになっています。 工夫した点としては、合法手を辞書型で管理し、そのキーをそのままユーザー入力のチェックに使うことで、処理を分かりやすくしました。また、両方のプレイヤーが打てる手がなくなった場合には自動的にゲームを終了し、count_pieces で石の枚数を数えて勝敗を表示するようにしています。",
    "code": "# 簡単なコンソール版オセロゲーム（Google Colabで動作）\n# 人間 vs 人間 または 人間 vs コンピューター（簡単AI）\n\nEMPTY = \".\"\nBLACK = \"B\"\nWHITE = \"W\"\n\n# 8方向（縦・横・斜め）\nDIRECTIONS = [\n    (-1, -1), (-1, 0), (-1, 1),\n    (0, -1),           (0, 1),\n    (1, -1),  (1, 0),  (1, 1)\n]\n\n\ndef init_board():\n    \"\"\"8x8の初期盤面を作成する\"\"\"\n    board = [[EMPTY for _ in range(8)] for _ in range(8)]\n    # 初期配置\n    board[3][3] = WHITE\n    board[3][4] = BLACK\n    board[4][3] = BLACK\n    board[4][4] = WHITE\n    return board\n\n\ndef print_board(board):\n    \"\"\"盤面をコンソールに表示する\"\"\"\n    print(\"  \", end=\"\")\n    for c in range(8):\n        print(c + 1, end=\" \")\n    print()\n    for r in range(8):\n        print(r + 1, end=\" \")\n        for c in range(8):\n            print(board[r][c], end=\" \")\n        print()\n    print()\n\n\ndef inside(r, c):\n    \"\"\"盤面の範囲内かどうか\"\"\"\n    return 0 <= r < 8 and 0 <= c < 8\n\n\ndef opponent(color):\n    \"\"\"相手の色を返す\"\"\"\n    return BLACK if color == WHITE else WHITE\n\n\ndef get_flips(board, row, col, color):\n    \"\"\"\n    指定したマスに打ったときにひっくり返る石のリストを返す。\n    row, col は 0 始まり（内部用）。\n    \"\"\"\n    # すでに石がある場所には打てない\n    if board[row][col] != EMPTY:\n        return []\n\n    opp = opponent(color)\n    flips = []\n\n    # 8方向をすべてチェック\n    for dr, dc in DIRECTIONS:\n        r, c = row + dr, col + dc\n        line = []\n\n        # 相手の石が続いている間は進む\n        while inside(r, c) and board[r][c] == opp:\n            line.append((r, c))\n            r += dr\n            c += dc\n\n        # 1個以上相手の石があり、その先に自分の石があればひっくり返せる\n        if line and inside(r, c) and board[r][c] == color:\n            flips.extend(line)\n\n    return flips\n\n\ndef get_valid_moves(board, color):\n    \"\"\"\n    color のプレイヤーが打てる合法手の辞書を返す。\n    キー: (row, col)  バリュー: ひっくり返る石のリスト\n    \"\"\"\n    moves = {}\n    for r in range(8):\n        for c in range(8):\n            fl = get_flips(board, r, c, color)\n            if fl:\n                moves[(r, c)] = fl\n    return moves\n\n\ndef apply_move(board, row, col, color, flips):\n    \"\"\"指定のマスに石を置き、ひっくり返す\"\"\"\n    board[row][col] = color\n    for r, c in flips:\n        board[r][c] = color\n\n\ndef count_pieces(board):\n    \"\"\"盤面上の黒・白の石の数を数える\"\"\"\n    b = sum(row.count(BLACK) for row in board)\n    w = sum(row.count(WHITE) for row in board)\n    return b, w\n\n\ndef choose_ai_move(valid_moves):\n    \"\"\"\n    とても単純なAI：\n    ひっくり返す枚数が最大になる手を選ぶ\n    \"\"\"\n    best_move = None\n    best_score = -1\n    for (r, c), flips in valid_moves.items():\n        if len(flips) > best_score:\n            best_score = len(flips)\n            best_move = (r, c)\n    return best_move\n\n\ndef game():\n    \"\"\"\n    ゲーム全体の流れを管理するメイン関数。\n    Google Colabでこの関数を呼び出してプレイする。\n    \"\"\"\n    board = init_board()\n    current = BLACK  # 黒からスタート\n    human_color = BLACK  # vs コンピューターのとき人間は黒固定\n\n    print(\"オセロゲーム開始\")\n    mode = None\n    while mode not in (\"1\", \"2\"):\n        mode = input(\"対戦モードを選んでください：1) 人間 vs 人間  2) 人間 vs コンピューター >>> \").strip()\n    vs_ai = (mode == \"2\")\n\n    print_board(board)\n\n    pass_count = 0  # 両方連続でパスが出たら終了\n\n    while True:\n        b, w = count_pieces(board)\n        print(f\"石の数: 黒={b}, 白={w}\")\n\n        valid = get_valid_moves(board, current)\n\n        # 打てる手がない場合\n        if not valid:\n            print((\"黒\" if current == BLACK else \"白\") + \"は打てる場所がありません。パスします。\")\n            pass_count += 1\n            if pass_count >= 2:\n                # 両者連続パスでゲーム終了\n                break\n            current = opponent(current)\n            continue\n        else:\n            pass_count = 0\n\n        print((\"黒\" if current == BLACK else \"白\") + \"の番です。\")\n        print(\"打てる場所（行, 列）:\")\n        for (r, c) in valid.keys():\n            print(f\"({r + 1}, {c + 1})\", end=\" \")\n        print(\"\\n\")\n\n        # コンピューターの手番\n        if vs_ai and current != human_color:\n            row, col = choose_ai_move(valid)\n            print(f\"コンピューターが({row + 1}, {col + 1})に打ちました。\")\n            flips = valid[(row, col)]\n            apply_move(board, row, col, current, flips)\n\n        # 人間の手番\n        else:\n            while True:\n                s = input(\"行と列をスペース区切りで入力してください（例: 3 4）。終了するには q: \")\n                s = s.strip()\n\n                if s.lower() == \"q\":\n                    print(\"ゲームを終了します。\")\n                    return\n\n                parts = s.split()\n                if len(parts) != 2:\n                    print(\"入力形式が違います。例: 3 4\")\n                    continue\n\n                try:\n                    r = int(parts[0]) - 1\n                    c = int(parts[1]) - 1\n                except ValueError:\n                    print(\"数字を入力してください。\")\n                    continue\n\n                if (r, c) not in valid:\n                    print(\"そこには打てません。もう一度。\")\n                    continue\n\n                flips = valid[(r, c)]\n                apply_move(board, r, c, current, flips)\n                break\n\n        print_board(board)\n        current = opponent(current)\n\n    # ゲーム終了\n    b, w = count_pieces(board)\n    print(\"ゲーム終了\")\n    print_board(board)\n    print(f\"最終結果: 黒={b}, 白={w}\")\n    if b > w:\n        print(\"黒の勝ちです。\")\n    elif w > b:\n        print(\"白の勝ちです。\")\n        print()\n    else:\n        print(\"引き分けです。\")\n\n\n# ここまでがプログラム本体。\n# Colabでは、このセルを実行したあと、\n# 別のセルで `game()` と入力して実行するとゲームが始まります。"
  },
  {
    "name": "Rion",
    "description": "このプログラムは、人間とAIが対戦するオセロゲームです。コンソール上に8×8の盤面を表示し、プレイヤーは列(A〜H)と行(1〜8)を入力して石を配置します。AIは角 → 辺 → 反転枚数最大という優先順位に基づいて手を選ぶようにしており、単純なランダムではなく、簡易的な戦略に従って打つように工夫しました。",
    "code": "board = [[\" \" for _ in range(8)] for _ in range(8)]\nboard[3][3] = \"W\"\nboard[3][4] = \"B\"\nboard[4][3] = \"B\"\nboard[4][4] = \"W\"\ndef print_board(board):\n    columns = \"A B C D E F G H\".split()\n    cell_width = 7\n    vertical_line_width = 1\n    cell_total_width = cell_width + vertical_line_width\n    header = \" \" * 4\n    for c in columns:\n        header += c.center(cell_total_width)\n    print(header)\n    horizontal_line = \"  \" + \"-\" * (cell_width * 8 + 9)\n    print(horizontal_line)\n    for i, row in enumerate(board):\n        row_str = \"\"\n        row_str += f\"{i + 1:< 2}|\"\n        for cell in row:\n            row_str += cell.center(cell_width) + \"|\"\n        print(row_str)\n        print(horizontal_line)\nprint_board(board)\n\ndef inside_board(r, c):\n    return 0 <= r < 8 and 0 <= c < 8\ndef opponent(player):\n    return \"B\" if player == \"W\" else \"W\"\nDIRECTIONS = [\n    (-1, -1), (-1, 0), (-1, 1),\n    (0, -1),          (0, 1),\n    (1, -1), (1, 0), (1, 1)\n]\ndef can_flip(board, r, c, player):\n    if board[r][c] != \" \":\n        return[]\n    flips = []\n    opp = opponent(player)\n    for dr, dc in DIRECTIONS:\n        nr, nc = r + dr, c + dc\n        line = []\n        while inside_board(nr, nc) and board[nr][nc] == opp:\n            line.append((nr, nc))\n            nr += dr\n            nc += dc\n        if inside_board(nr, nc) and board[nr][nc] == player and len(line) > 0:\n            flips.extend(line)\n    return flips\ndef place_and_flip(board, r, c, player):\n    flips = can_flip(board, r, c, player)\n    if not flips:\n        return False\n    board[r][c] = player\n    for fr, fc in flips:\n        board[fr][fc] = player\n    return True\ndef get_all_valid_moves(board, player):\n    moves = []\n    for r in range(8):\n        for c in range(8):\n            if can_flip(board, r, c, player):\n                moves.append((r, c))\n    return moves\ndef human_move(board, player):\n    moves = get_all_valid_moves(board, player)\n    if not moves:\n        print(\"※あなたは置ける場所がありません。パスします。\\n\")\n        return  \"pass\"\n    while True:\n        col = input(\"列番号を入力してください(A~H):\").upper()\n        row = input(\"行番号を入力してください(1~8):\")\n        if col not in \"ABCDEFGH\":\n            print(\"※列番号はA~Hで入力してください。\")\n            continue\n        if not row.isdigit() or not (1 <= int(row) <= 8):\n            print(\"※行番号は1~8で入力してください。\")\n            continue\n        c = \"ABCDEFGH\".index(col)\n        r = int(row) - 1\n        if place_and_flip(board, r, c, player):\n            print(f\"\\nあなたは{col}{row}に置きました。\\n\")\n            return\n        else:\n            print(\"※その場所には置けません。\")\n            print(\"別の場所を選んでください。\\n\")\n\ndef ai_move(board, player):\n    moves = get_all_valid_moves(board, player)\n    if not moves:\n        print(\"※AIは置ける場所がありません。パスします。\\n\")\n        return \"pass\"\n    corners = [(0,0), (0,7), (7,0), (7,7)]\n    corner_moves = [move for move in moves if move in corners]\n    if corner_moves:\n        r, c = corner_moves[0]\n        place_and_flip(board, r, c, player)\n        print(f\"AIは{(chr(c+65))}{r+1}に置きました。\\n\")\n    elif any(r in (0,7) or c in (0,7) for r, c in moves):\n        edge_moves = [(r, c) for r, c in moves if r in(0,7) or c in (0,7)]\n        r, c = edge_moves[0]\n        place_and_flip(board, r, c, player)\n        print(f\"AIは{(chr(c+65))}{r+1}に置きました。\\n\")\n    else:\n        best_move = max(moves, key=lambda rc: len(can_flip(board, rc[0], rc[1], player)))\n        r, c = best_move\n        place_and_flip(board, r, c, player)4\n        print(f\"AIは{(chr(c+65))}{r+1}に置きました。\\n\")\n\ndef count_stones(board):\n    black = sum(row.count(\"B\") for row in board)\n    white = sum(row.count(\"W\") for row in board)\n    return black, white\ndef show_winner(board):\n    black, white = count_stones(board)\n    print(f\"ゲーム終了!\\n黒(B):{black} 白(W):{white}\")\n    if black > white:\n        print(\"あなたの勝ちです!\")\n    elif white > black:\n        print(\"AIの勝ちです!\")\n    else:\n        print(\"引き分けです!\")\ndef play_game():\n    while True:\n        board = [[\" \" for _ in range(8)] for _ in range(8)]\n        board[3][3] = \"W\"\n        board[3][4] = \"B\"\n        board[4][3] = \"B\"\n        board[4][4] = \"W\"\n        player = \"B\"\n        last_result = None\n        while True:\n            print_board(board)\n            print(f\"現在のターン:{player}\")\n            if player == \"B\":\n                result = human_move(board, player)\n            else:\n                result = ai_move(board, player)\n            if result == \"pass\":\n                if last_result == \"pass\":\n                    print(\"両者連続パスのためゲーム終了です。\")\n                    print_board(board)\n                    show_winner(board)\n                    break\n                last_result = \"pass\"\n                player = opponent(player)\n                continue\n            last_result = \"move\"\n            player = opponent(player)\n        while True:\n            again = input(\"もう一度遊びますか?(はい/いいえ):\").strip()\n            if again == \"はい\":\n                break\n            elif again == \"いいえ\":\n                print(\"ゲームを終了します。\")\n                return\n            else:\n                print(\"※「はい」か「いいえ」で入力してください。\")\nplay_game()"
  },
  {
    "name": "Haruki",
    "description": "おける場所が表示されるので行→列の順で入力",
    "code": "import numpy as np\n\n# 盤面の初期化\ndef init_board():\n    board = np.full((8, 8), \".\")\n    board[3][3] = \"W\"\n    board[3][4] = \"B\"\n    board[4][3] = \"B\"\n    board[4][4] = \"W\"\n    return board\n\n# 盤面表示\ndef print_board(board):\n    print(\"  0 1 2 3 4 5 6 7\")\n    for i in range(8):\n        print(i, \" \".join(board[i]))\n\n# 8方向\ndirections = [\n    (-1, 0), (1, 0), (0, -1), (0, 1),\n    (-1, -1), (-1, 1), (1, -1), (1, 1)\n]\n\n# 石を置ける場所の判定\ndef valid_moves(board, player):\n    opponent = \"W\" if player == \"B\" else \"B\"\n    moves = []\n\n    for r in range(8):\n        for c in range(8):\n            if board[r][c] != \".\":\n                continue\n\n            valid = False\n            for dr, dc in directions:\n                nr, nc = r + dr, c + dc\n                flipped = False\n\n                while 0 <= nr < 8 and 0 <= nc < 8 and board[nr][nc] == opponent:\n                    nr += dr\n                    nc += dc\n                    flipped = True\n\n                if flipped and 0 <= nr < 8 and 0 <= nc < 8 and board[nr][nc] == player:\n                    valid = True\n                    break\n\n            if valid:\n                moves.append((r, c))\n\n    return moves\n\n# 石を置いてひっくり返す\ndef place_piece(board, r, c, player):\n    opponent = \"W\" if player == \"B\" else \"B\"\n    board[r][c] = player\n\n    for dr, dc in directions:\n        nr, nc = r + dr, c + dc\n        path = []\n\n        while 0 <= nr < 8 and 0 <= nc < 8 and board[nr][nc] == opponent:\n            path.append((nr, nc))\n            nr += dr\n            nc += dc\n\n        if path and 0 <= nr < 8 and 0 <= nc < 8 and board[nr][nc] == player:\n            for pr, pc in path:\n                board[pr][pc] = player\n\n# メインゲームループ\ndef play_othello():\n    board = init_board()\n    player = \"B\"\n\n    while True:\n        print_board(board)\n        print(f\"現在の手番: {player}\")\n\n        moves = valid_moves(board, player)\n\n        if not moves:\n            print(f\"{player} は置ける場所がありません。パスします。\")\n            player = \"W\" if player == \"B\" else \"B\"\n            continue\n\n        print(\"置ける場所:\", moves)\n\n        r, c = map(int, input(\"行と列をスペース区切りで入力: \").split())\n\n        if (r, c) not in moves:\n            print(\"その場所には置けません。もう一度。\")\n            continue\n\n        place_piece(board, r, c, player)\n\n        player = \"W\" if player == \"B\" else \"B\"\n\n# 実行\nplay_othello()"
  },
  {
    "name": "Ryuta",
    "description": "今回作成したオセロゲームでは、本来はマウスでマスをクリックして石を置く方法を試していました。しかし、Google Colab の環境ではクリックがうまく反応せず、エラーが出てしまいました。そのため、クリック操作をやめて、「行」と「列」の番号をキーボードから入力して石を置く方式に変更した点が工夫したところです。プログラムの中では、ユーザーから行番号と列番号を input() で受け取り、そこが有効な手かどうかを判定してから石を置くようにしています。置いた後は盤面をテキストとして表示するようにして、毎回状況が分かるようにしました。",
    "code": "import numpy as np\n\nEMPTY, BLACK, WHITE = 0, 1, -1\n\n# 初期盤面\nboard = np.zeros((8, 8), dtype=int)\nboard[3, 3], board[4, 4] = WHITE, WHITE\nboard[3, 4], board[4, 3] = BLACK, BLACK\n\ndirections = [\n    (1, 0), (-1, 0), (0, 1), (0, -1),\n    (1, 1), (-1, -1), (1, -1), (-1, 1)\n]\n\ndef print_board():\n    print(\"  0 1 2 3 4 5 6 7\")\n    for i in range(8):\n        row = \"\"\n        for j in range(8):\n            if board[i][j] == BLACK:\n                row += \" ●\"\n            elif board[i][j] == WHITE:\n                row += \" ○\"\n            else:\n                row += \" ・\"\n        print(i, row)\n\ndef valid_moves(player):\n    moves = []\n    for r in range(8):\n        for c in range(8):\n            if board[r, c] != EMPTY:\n                continue\n            flips = []\n            for dr, dc in directions:\n                rr, cc = r + dr, c + dc\n                temp = []\n                while 0 <= rr < 8 and 0 <= cc < 8 and board[rr, cc] == -player:\n                    temp.append((rr, cc))\n                    rr += dr\n                    cc += dc\n                if temp and 0 <= rr < 8 and 0 <= cc < 8 and board[rr, cc] == player:\n                    flips.extend(temp)\n            if flips:\n                moves.append((r, c, flips))\n    return moves\n\ndef place(player, r, c, flips):\n    board[r][c] = player\n    for rr, cc in flips:\n        board[rr][cc] = player\n\ndef cpu_move(player):\n    moves = valid_moves(player)\n    if not moves:\n        return False\n    r, c, flips = moves[np.random.randint(len(moves))]\n    place(player, r, c, flips)\n    print(f\"\\nCPU（白）が ({r}, {c}) に置きました。\\n\")\n    return True\n\n# --- ゲーム開始 ---\ncurrent = BLACK  # プレイヤー\n\nwhile True:\n    print_board()\n\n    moves = valid_moves(current)\n    if not moves:\n        print(\"\\n置ける場所がありません。ターンをスキップします。\\n\")\n        current = -current\n        continue\n\n    if current == BLACK:\n        print(\"\\nあなたの番です（黒●）\")\n        print(\"置ける場所:\", [(r, c) for r, c, _ in moves])\n\n        r = int(input(\"行番号を入力: \"))\n        c = int(input(\"列番号を入力: \"))\n\n        placed = False\n        for mr, mc, flips in moves:\n            if mr == r and mc == c:\n                place(current, r, c, flips)\n                placed = True\n                break\n\n        if not placed:\n            print(\"そこには置けません。やり直してください。\")\n            continue\n\n        current = WHITE\n\n    else:\n        cpu_move(WHITE)\n        current = BLACK"
  }
]