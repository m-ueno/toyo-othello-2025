[
  {
    "name": "Mahiro",
    "description": "",
    "code": "import random\n\nclass Othello:\n    def __init__(self):\n        self.board = [['.' for _ in range(8)] for _ in range(8)]\n        self.board[3][3] = 'O'\n        self.board[3][4] = 'X'\n        self.board[4][3] = 'X'\n        self.board[4][4] = 'O'\n        self.turn = 'X'\n\n    def show(self):\n        for row in self.board:\n            print(' '.join(row))\n        print()\n\n    def inside(self, x, y):\n        return 0 <= x < 8 and 0 <= y < 8\n\n    def valid_moves(self):\n        moves = []\n        for x in range(8):\n            for y in range(8):\n                if self.board[x][y] == '.':\n                    moves.append((x, y))\n        return moves\n\n    def move(self, x, y):\n        if self.board[x][y] != '.':\n            return\n        self.board[x][y] = self.turn\n        self.turn = 'O' if self.turn == 'X' else 'X'\n\n    def play_ai(self):\n        moves = self.valid_moves()\n        if moves:\n            x, y = random.choice(moves)\n            self.move(x, y)\n\n# å®Ÿè¡Œéƒ¨åˆ†\ngame = Othello()\nfor _ in range(20):\n    game.show()\n    game.play_ai()"
  },
  {
    "name": "Hayate",
    "description": "",
    "code": "import random\n\nclass Board:\n    EMPTY = \"ãƒ»\"\n    BLACK = \"â—\"\n    WHITE = \"â—‹\"\n\n    DIRECTIONS = [\n        (-1, -1), (-1, 0), (-1, 1),\n        (0, -1),          (0, 1),\n        (1, -1),  (1, 0), (1, 1)\n    ]\n\n    def __init__(self):\n        self.board = [[self.EMPTY for _ in range(8)] for _ in range(8)]\n        self.board[3][3] = self.WHITE\n        self.board[3][4] = self.BLACK\n        self.board[4][3] = self.BLACK\n        self.board[4][4] = self.WHITE\n\n    def print_board(self):\n        print(\"   ï¼ ï¼‘ ï¼’ ï¼“ ï¼” ï¼• ï¼– ï¼—\")\n        for i in range(8):\n            print(f\" {i} \", end=\"\")\n            for j in range(8):\n                print(self.board[i][j], end=\" \")\n            print()\n        print()\n\n    def in_bounds(self, x, y):\n        return 0 <= x < 8 and 0 <= y < 8\n\n    def can_flip(self, x, y, player, dx, dy):\n        opponent = self.WHITE if player == self.BLACK else self.BLACK\n        x += dx\n        y += dy\n        if not self.in_bounds(x, y) or self.board[x][y] != opponent:\n            return False\n        while self.in_bounds(x, y):\n            if self.board[x][y] == self.EMPTY:\n                return False\n            if self.board[x][y] == player:\n                return True\n            x += dx\n            y += dy\n        return False\n\n    def is_valid_move(self, x, y, player):\n        if not self.in_bounds(x, y) or self.board[x][y] != self.EMPTY:\n            return False\n        for dx, dy in self.DIRECTIONS:\n            if self.can_flip(x, y, player, dx, dy):\n                return True\n        return False\n\n    def place_stone(self, x, y, player):\n        self.board[x][y] = player\n        for dx, dy in self.DIRECTIONS:\n            if self.can_flip(x, y, player, dx, dy):\n                cx, cy = x + dx, y + dy\n                while self.board[cx][cy] != player:\n                    self.board[cx][cy] = player\n                    cx += dx\n                    cy += dy\n\n    def has_valid_moves(self, player):\n        for i in range(8):\n            for j in range(8):\n                if self.is_valid_move(i, j, player):\n                    return True\n        return False\n\n    def get_valid_moves(self, player):\n        moves = []\n        for i in range(8):\n            for j in range(8):\n                if self.is_valid_move(i, j, player):\n                    moves.append((i, j))\n        return moves\n\n    def count_stones(self):\n        black = white = 0\n        for row in self.board:\n            for cell in row:\n                if cell == self.BLACK:\n                    black += 1\n                elif cell == self.WHITE:\n                    white += 1\n        return black, white\n\n\nclass OthelloGame:\n    def __init__(self):\n        self.board = Board()\n        self.current_player = Board.BLACK\n\n    def switch_player(self):\n        self.current_player = (\n            Board.WHITE if self.current_player == Board.BLACK else Board.BLACK\n        )\n\n    def cpu_move(self):\n        moves = self.board.get_valid_moves(Board.WHITE)\n        if moves:\n            x, y = random.choice(moves)\n            print(f\"CPUã¯ ({x}, {y}) ã«ç½®ãã¾ã—ãŸ\")\n            self.board.place_stone(x, y, Board.WHITE)\n\n    def play(self):\n        while True:\n            self.board.print_board()\n            black, white = self.board.count_stones()\n            print(f\"ã‚ãªãŸ(â—): {black}  CPU(â—‹): {white}\")\n\n            if not self.board.has_valid_moves(self.current_player):\n                print(\"ç½®ã‘ã‚‹å ´æ‰€ãŒãªã„ãŸã‚ãƒ‘ã‚¹ã—ã¾ã™ã€‚\")\n                self.switch_player()\n                if not self.board.has_valid_moves(self.current_player):\n                    print(\"ä¸¡è€…ã¨ã‚‚ç½®ã‘ãªã„ãŸã‚ã‚²ãƒ¼ãƒ çµ‚äº†ã€‚\")\n                    break\n                continue\n\n            if self.current_player == Board.BLACK:\n                print(\"ã‚ãªãŸã®ç•ªã§ã™\")\n                try:\n                    x = int(input(\"è¡Œ (0-7): \"))\n                    y = int(input(\"åˆ— (0-7): \"))\n                except:\n                    print(\"æ•°å­—ã‚’å…¥åŠ›ã—ã¦ãã ã•ã„ã€‚\")\n                    continue\n                if not self.board.is_valid_move(x, y, Board.BLACK):\n                    print(\"ãã“ã«ã¯ç½®ã‘ã¾ã›ã‚“ã€‚\")\n                    continue\n                self.board.place_stone(x, y, Board.BLACK)\n            else:\n                print(\"CPUã®ç•ªã§ã™...\")\n                self.cpu_move()\n\n            self.switch_player()\n\n        self.board.print_board()\n        black, white = self.board.count_stones()\n        print(\"æœ€çµ‚çµæœ\")\n        print(f\"ã‚ãªãŸ(â—): {black}  CPU(â—‹): {white}\")\n\n\n# å®Ÿè¡Œ\ngame = OthelloGame()\ngame.play()\n"
  },
  {
    "name": "hirobe",
    "description": "",
    "code": "import random\n\nclass Othello:\n    EMPTY = 0\n    BLACK = 1\n    WHITE = 2\n\n    DIRECTIONS = [\n        (-1, -1), (-1, 0), (-1, 1),\n        (0, -1),          (0, 1),\n        (1, -1),  (1, 0), (1, 1)\n    ]\n\n    def __init__(self):\n        # 8Ã—8 ã®ç›¤\n        self.board = [[self.EMPTY for _ in range(8)] for _ in range(8)]\n        # åˆæœŸé…ç½®\n        self.board[3][3] = self.WHITE\n        self.board[3][4] = self.BLACK\n        self.board[4][3] = self.BLACK\n        self.board[4][4] = self.WHITE\n\n        self.turn = self.BLACK  # å…ˆæ‰‹ã¯é»’\n\n    def inside(self, x, y):\n        return 0 <= x < 8 and 0 <= y < 8\n\n    def opponent(self, color):\n        return self.BLACK if color == self.WHITE else self.WHITE\n\n    def valid_moves(self, color):\n        moves = []\n        for x in range(8):\n            for y in range(8):\n                if self.board[x][y] == self.EMPTY:\n                    if self.can_flip(x, y, color):\n                        moves.append((x, y))\n        return moves\n\n    def can_flip(self, x, y, color):\n        # ç½®ã‘ã‚‹ã‹ã©ã†ã‹ãƒã‚§ãƒƒã‚¯\n        opp = self.opponent(color)\n        for dx, dy in self.DIRECTIONS:\n            nx, ny = x + dx, y + dy\n            found_opp = False\n\n            while self.inside(nx, ny) and self.board[nx][ny] == opp:\n                found_opp = True\n                nx += dx\n                ny += dy\n\n            if found_opp and self.inside(nx, ny) and self.board[nx][ny] == color:\n                return True\n        return False\n\n    def place(self, x, y, color):\n        # çŸ³ã‚’ç½®ã„ã¦è£è¿”ã™\n        self.board[x][y] = color\n        opp = self.opponent(color)\n\n        for dx, dy in self.DIRECTIONS:\n            nx, ny = x + dx, y + dy\n            stones = []\n\n            while self.inside(nx, ny) and self.board[nx][ny] == opp:\n                stones.append((nx, ny))\n                nx += dx\n                ny += dy\n\n            if stones and self.inside(nx, ny) and self.board[nx][ny] == color:\n                for sx, sy in stones:\n                    self.board[sx][sy] = color\n\n    def print_board(self):\n        print(\"  0 1 2 3 4 5 6 7\")\n        for i, row in enumerate(self.board):\n            print(i, end=\" \")\n            for cell in row:\n                if cell == self.EMPTY:\n                    print(\".\", end=\" \")\n                elif cell == self.BLACK:\n                    print(\"B\", end=\" \")\n                else:\n                    print(\"W\", end=\" \")\n            print()\n        print()\n\n    def is_game_over(self):\n        return len(self.valid_moves(self.BLACK)) == 0 and len(self.valid_moves(self.WHITE)) == 0\n\n    def count_stones(self):\n        b = sum(row.count(self.BLACK) for row in self.board)\n        w = sum(row.count(self.WHITE) for row in self.board)\n        return b, w\n\n\nclass RandomAI:\n    \"\"\"ãƒ©ãƒ³ãƒ€ãƒ ã«åˆæ³•æ‰‹ã‚’é¸ã¶AIï¼ˆã¾ãšã¯ç°¡å˜ãªãƒãƒ¼ã‚¸ãƒ§ãƒ³ï¼‰\"\"\"\n    def choose_move(self, game, color):\n        moves = game.valid_moves(color)\n        if not moves:\n            return None\n        return random.choice(moves)\n\n\n# ====== å®Ÿè¡Œéƒ¨åˆ† ======\ngame = Othello()\nai = RandomAI()\n\nprint(\"ã‚ªã‚»ãƒ­é–‹å§‹ï¼é»’(B) ãŒå…ˆæ‰‹ã§ã™ï¼\")\ngame.print_board()\n\nwhile not game.is_game_over():\n    if game.turn == Othello.BLACK:\n        # äººé–“ã®ã‚¿ãƒ¼ãƒ³\n        moves = game.valid_moves(Othello.BLACK)\n        if not moves:\n            print(\"é»’ã¯ãƒ‘ã‚¹ï¼\")\n            game.turn = Othello.WHITE\n            continue\n\n        print(\"é»’ã®åˆæ³•æ‰‹:\", moves)\n        x, y = map(int, input(\"é»’ã®æ‰‹ã‚’å…¥åŠ›ï¼ˆä¾‹: 2 3ï¼‰â†’ \").split())\n        if (x, y) not in moves:\n            print(\"ãã®æ‰‹ã¯æ‰“ã¦ã¾ã›ã‚“ï¼\")\n            continue\n\n        game.place(x, y, Othello.BLACK)\n\n    else:\n        # AI ã®ã‚¿ãƒ¼ãƒ³ï¼ˆç™½ï¼‰\n        moves = game.valid_moves(Othello.WHITE)\n        if not moves:\n            print(\"ç™½ã¯ãƒ‘ã‚¹ï¼\")\n            game.turn = Othello.BLACK\n            continue\n\n        move = ai.choose_move(game, Othello.WHITE)\n        print(\"AI ã®æ‰‹:\", move)\n        game.place(move[0], move[1], Othello.WHITE)\n\n    game.print_board()\n\n    # æ‰‹ç•ªäº¤ä»£\n    game.turn = game.opponent(game.turn)\n\n# ====== çµæœ ======\nb, w = game.count_stones()\nprint(\"ã‚²ãƒ¼ãƒ çµ‚äº†ï¼\")\nprint(f\"é»’: {b}  ç™½: {w}\")\nif b > w:\n    print(\"é»’ã®å‹ã¡ï¼\")\nelif w > b:\n    print(\"ç™½ã®å‹ã¡ï¼\")\nelse:\n    print(\"å¼•ãåˆ†ã‘ï¼\")\n"
  },
  {
    "name": "Rami",
    "description": "",
    "code": "import numpy as np\nimport random\n\n# ===============================\n# Board ã‚¯ãƒ©ã‚¹ï¼ˆç¾éº—ç›¤é¢ä»˜ãï¼‰\n# ===============================\nclass Board:\n    def __init__(self):\n        self.board = np.zeros((8, 8), dtype=int)\n        self.board[3][3] = 1  # ç™½\n        self.board[4][4] = 1  # ç™½\n        self.board[3][4] = -1 # é»’\n        self.board[4][3] = -1 # é»’\n\n    def copy(self):\n        new_board = Board()\n        new_board.board = self.board.copy()\n        return new_board\n\n    # ğŸ¨ è¦‹ã‚„ã™ã„ ANSI ã‚«ãƒ©ãƒ¼ãƒœãƒ¼ãƒ‰\n    def print_board(self):\n        RESET = \"\\033[0m\"\n        BG1   = \"\\033[48;5;236m\"   # ãƒ€ãƒ¼ã‚¯ã‚°ãƒ¬ãƒ¼\n        BG2   = \"\\033[48;5;250m\"   # ãƒ©ã‚¤ãƒˆã‚°ãƒ¬ãƒ¼\n        BLACK = \"\\033[38;5;0mâ—\"\n        WHITE = \"\\033[38;5;15mâ—‹\"\n\n        print(\"\\n     a   b   c   d   e   f   g   h\")\n        print(\"   +---------------------------------+\")\n\n        for r in range(8):\n            row_str = f\" {r+1} |\"\n            for c in range(8):\n                bg = BG1 if (r+c) % 2 == 0 else BG2\n                v = self.board[r, c]\n                if v == -1:\n                    stone = BLACK\n                elif v == 1:\n                    stone = WHITE\n                else:\n                    stone = \" \"\n                row_str += f\"{bg} {stone} {RESET}\"\n            row_str += \"|\"\n            print(row_str)\n\n        print(\"   +---------------------------------+\\n\")\n\n    def is_valid_move(self, row, col, player):\n        if self.board[row, col] != 0:\n            return False\n        \n        directions = [(-1,-1),(-1,0),(-1,1),(0,-1),(0,1),(1,-1),(1,0),(1,1)]\n        opp = -player\n\n        for dr, dc in directions:\n            r, c = row + dr, col + dc\n            if not (0 <= r < 8 and 0 <= c < 8):\n                continue\n            if self.board[r, c] != opp:\n                continue\n\n            while 0 <= r < 8 and 0 <= c < 8:\n                r += dr\n                c += dc\n                if not (0 <= r < 8 and 0 <= c < 8):\n                    break\n                if self.board[r, c] == player:\n                    return True\n                if self.board[r, c] == 0:\n                    break\n        return False\n\n    def flip_stones(self, row, col, player):\n        directions = [(-1,-1),(-1,0),(-1,1),(0,-1),(0,1),(1,-1),(1,0),(1,1)]\n        opp = -player\n\n        for dr, dc in directions:\n            r, c = row + dr, col + dc\n            stones = []\n\n            while 0 <= r < 8 and 0 <= c < 8 and self.board[r,c] == opp:\n                stones.append((r,c))\n                r += dr\n                c += dc\n\n            if 0 <= r < 8 and 0 <= c < 8 and self.board[r,c] == player:\n                for rr, cc in stones:\n                    self.board[rr, cc] = player\n\n    def get_valid_moves(self, player):\n        return [(r,c) for r in range(8) for c in range(8) if self.is_valid_move(r,c,player)]\n\n    def is_game_over(self):\n        return (len(self.get_valid_moves(1)) == 0 and \n                len(self.get_valid_moves(-1)) == 0)\n\n    def count_stones(self):\n        b = np.sum(self.board == -1)\n        w = np.sum(self.board == 1)\n        return b, w\n\n\n# ===============================\n# Player ã‚¯ãƒ©ã‚¹\n# ===============================\nclass Player:\n    def __init__(self, color):\n        self.color = color\n\n    def get_move(self, board):\n        raise NotImplementedError\n\n\n# ===============================\n# Human Player\n# ===============================\nclass HumanPlayer(Player):\n    def get_move(self, board):\n        valid = board.get_valid_moves(self.color)\n        if not valid:\n            print(\"åˆæ³•æ‰‹ãªã— â†’ ãƒ‘ã‚¹\")\n            return None, None\n\n        print(f\"ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ {'é»’(â—)' if self.color==-1 else 'ç™½(â—‹)'} ã®ç•ªã§ã™\")\n        print(\"åˆæ³•æ‰‹ï¼š\", \", \".join([f\"{chr(c+97)}{r+1}\" for r,c in valid]))\n\n        while True:\n            s = input(\"æ‰‹ã‚’å…¥åŠ›ï¼ˆä¾‹ a1ï¼‰: \").strip().lower()\n            if len(s) != 2:\n                print(\"å½¢å¼ãŒé•ã„ã¾ã™\")\n                continue\n            c = ord(s[0]) - 97\n            r = int(s[1]) - 1\n            if (r, c) in valid:\n                return r, c\n            print(\"ãã®å ´æ‰€ã«ã¯ç½®ã‘ã¾ã›ã‚“\")\n\n\n# ===============================\n# å¼±AIï¼ˆãƒ©ãƒ³ãƒ€ãƒ ï¼‰\n# ===============================\nclass RandomAI(Player):\n    def get_move(self, board):\n        valid = board.get_valid_moves(self.color)\n        if not valid:\n            print(\"å¼±AIï¼šãƒ‘ã‚¹\")\n            return None, None\n        move = random.choice(valid)\n        print(f\"å¼±AI ãŒ {chr(move[1]+97)}{move[0]+1} ã«ç½®ãã¾ã™\")\n        return move\n\n\n# ===============================\n# å¼·AIï¼ˆãƒŸãƒ‹ãƒãƒƒã‚¯ã‚¹ï¼‰\n# ===============================\nclass StrongAI(Player):\n    def __init__(self, color, depth=3):\n        super().__init__(color)\n        self.depth = depth\n        self.weights = np.array([\n            [120,-20,20,5,5,20,-20,120],\n            [-20,-40,-5,-5,-5,-5,-40,-20],\n            [20,-5,15,3,3,15,-5,20],\n            [5,-5,3,3,3,3,-5,5],\n            [5,-5,3,3,3,3,-5,5],\n            [20,-5,15,3,3,15,-5,20],\n            [-20,-40,-5,-5,-5,-5,-40,-20],\n            [120,-20,20,5,5,20,-20,120],\n        ])\n\n    def evaluate(self, b):\n        return np.sum(b.board * self.weights * self.color)\n\n    def minimax(self, board, depth, maximizing):\n        player = self.color if maximizing else -self.color\n        moves = board.get_valid_moves(player)\n\n        if depth == 0 or board.is_game_over():\n            return self.evaluate(board), None\n\n        if not moves:\n            return self.minimax(board, depth-1, not maximizing)[0], None\n\n        best_move = None\n\n        if maximizing:\n            best_val = -1e9\n            for move in moves:\n                nb = board.copy()\n                r, c = move\n                nb.board[r, c] = player\n                nb.flip_stones(r, c, player)\n                val, _ = self.minimax(nb, depth-1, False)\n                if val > best_val:\n                    best_val, best_move = val, move\n            return best_val, best_move\n\n        else:\n            best_val = 1e9\n            for move in moves:\n                nb = board.copy()\n                r, c = move\n                nb.board[r, c] = player\n                nb.flip_stones(r, c, player)\n                val, _ = self.minimax(nb, depth-1, True)\n                if val < best_val:\n                    best_val, best_move = val, move\n            return best_val, best_move\n\n    def get_move(self, board):\n        moves = board.get_valid_moves(self.color)\n        if not moves:\n            print(\"å¼·AIï¼šãƒ‘ã‚¹\")\n            return None, None\n        _, best = self.minimax(board, self.depth, True)\n        print(f\"å¼·AI ãŒ {chr(best[1]+97)}{best[0]+1} ã«ç½®ãã¾ã™\")\n        return best\n\n\n# ===============================\n# Game ã‚¯ãƒ©ã‚¹\n# ===============================\nclass Game:\n    def __init__(self, black, white):\n        self.board = Board()\n        self.players = {-1: black, 1: white}\n        self.turn = -1  # é»’\n\n    def switch(self):\n        self.turn *= -1\n\n    def start(self):\n        while not self.board.is_game_over():\n            self.board.print_board()\n            player = self.players[self.turn]\n            r, c = player.get_move(self.board)\n\n            if r is not None:\n                self.board.board[r, c] = self.turn\n                self.board.flip_stones(r, c, self.turn)\n\n            self.switch()\n\n        # çµæœ\n        self.board.print_board()\n        b, w = self.board.count_stones()\n        print(f\"é»’: {b}  ç™½: {w}\")\n        print(\"çµæœ:\", \"é»’ã®å‹ã¡\" if b>w else \"ç™½ã®å‹ã¡\" if w>b else \"å¼•ãåˆ†ã‘\")\n\n\n# ===============================\n# å®Ÿè¡Œãƒ¡ãƒ‹ãƒ¥ãƒ¼\n# ===============================\nprint(\"1: äººé–“ vs å¼±AI\")\nprint(\"2: äººé–“ vs å¼·AI\")\nprint(\"3: å¼±AI vs å¼·AI\")\nprint(\"4: å¼·AI vs å¼·AI\")\nmode = input(\"å¯¾æˆ¦ãƒ¢ãƒ¼ãƒ‰ã‚’é¸æŠ: \")\n\nif mode == \"1\":\n    game = Game(HumanPlayer(-1), RandomAI(1))\nelif mode == \"2\":\n    game = Game(HumanPlayer(-1), StrongAI(1, depth=3))\nelif mode == \"3\":\n    game = Game(RandomAI(-1), StrongAI(1, depth=3))\nelif mode == \"4\":\n    game = Game(StrongAI(-1, depth=3), StrongAI(1, depth=3))\nelse:\n    print(\"ä¸æ­£ãªå…¥åŠ›\")\n    raise SystemExit\n\ngame.start()\n"
  },
  {
    "name": "Aoto",
    "description": "",
    "code": "import numpy as np\nimport random\n\nclass OthelloBoard:\n    EMPTY = 0\n    BLACK = 1\n    WHITE = -1\n\n    DIRECTIONS = [\n        (-1, 0), (1, 0), (0, -1), (0, 1),\n        (-1, -1), (-1, 1), (1, -1), (1, 1)\n    ]\n\n    def __init__(self):\n        self.board = np.zeros((8, 8), dtype=int)\n        self.board[3, 3] = self.WHITE\n        self.board[3, 4] = self.BLACK\n        self.board[4, 3] = self.BLACK\n        self.board[4, 4] = self.WHITE\n\n    def print_board(self, valid_moves=None):\n        print(\"  0 1 2 3 4 5 6 7\")\n        for i in range(8):\n            row = \"\"\n            for j in range(8):\n                if valid_moves and (i, j) in valid_moves:\n                    row += \" *\"\n                elif self.board[i][j] == self.BLACK:\n                    row += \" B\"\n                elif self.board[i][j] == self.WHITE:\n                    row += \" W\"\n                else:\n                    row += \" .\"\n            print(i, row)\n\n    def get_valid_moves(self, player):\n        return [(r, c) for r in range(8) for c in range(8)\n                if self.board[r][c] == self.EMPTY and self.can_flip(r, c, player)]\n\n    def can_flip(self, r, c, player):\n        opponent = -player\n        for dr, dc in self.DIRECTIONS:\n            nr, nc = r + dr, c + dc\n            found = False\n            while 0 <= nr < 8 and 0 <= nc < 8:\n                if self.board[nr][nc] == opponent:\n                    found = True\n                    nr += dr\n                    nc += dc\n                elif self.board[nr][nc] == player and found:\n                    return True\n                else:\n                    break\n        return False\n\n    def place_stone(self, r, c, player):\n        self.board[r][c] = player\n        opponent = -player\n\n        for dr, dc in self.DIRECTIONS:\n            nr, nc = r + dr, c + dc\n            flip_list = []\n\n            while 0 <= nr < 8 and 0 <= nc < 8:\n                if self.board[nr][nc] == opponent:\n                    flip_list.append((nr, nc))\n                    nr += dr\n                    nc += dc\n                elif self.board[nr][nc] == player:\n                    for fr, fc in flip_list:\n                        self.board[fr][fc] = player\n                    break\n                else:\n                    break\n\n    def count_stones(self):\n        black = np.sum(self.board == self.BLACK)\n        white = np.sum(self.board == self.WHITE)\n        return black, white\n\n\nclass OthelloGame:\n    def __init__(self):\n        self.board = OthelloBoard()\n        self.current_player = OthelloBoard.BLACK\n\n    def play(self):\n        print(\"ã‚ªã‚»ãƒ­ã‚²ãƒ¼ãƒ é–‹å§‹ï¼ï¼ˆã‚ãªãŸï¼šé»’ Bï¼‰\")\n\n        while True:\n            valid_moves = self.board.get_valid_moves(self.current_player)\n\n            print(\"\\nç¾åœ¨ã®ç›¤é¢\")\n            self.board.print_board(valid_moves)\n            black, white = self.board.count_stones()\n            print(f\"çŸ³ã®æ•° â†’ é»’:{black} ç™½:{white}\")\n\n            if not valid_moves:\n                print(\"åˆæ³•æ‰‹ãªã— â†’ ãƒ‘ã‚¹\")\n                self.current_player *= -1\n                if not self.board.get_valid_moves(self.current_player):\n                    print(\"\\nä¸¡è€…ãƒ‘ã‚¹ â†’ ã‚²ãƒ¼ãƒ çµ‚äº†\")\n                    break\n                continue\n\n            if self.current_player == OthelloBoard.BLACK:\n                self.player_turn(valid_moves)\n            else:\n                self.cpu_turn(valid_moves)\n\n            self.current_player *= -1\n\n        self.show_result()\n\n    def player_turn(self, valid_moves):\n        while True:\n            try:\n                r, c = map(int, input(\"è¡Œ åˆ— ã‚’å…¥åŠ›: \").split())\n                if (r, c) in valid_moves:\n                    self.board.place_stone(r, c, self.current_player)\n                    break\n                else:\n                    print(\"ãã“ã«ã¯ç½®ã‘ã¾ã›ã‚“\")\n            except:\n                print(\"å…¥åŠ›ã‚¨ãƒ©ãƒ¼\")\n\n    def cpu_turn(self, valid_moves):\n        move = random.choice(valid_moves)\n        print(f\"CPUãŒ ({move[0]}, {move[1]}) ã«ç½®ãã¾ã—ãŸ\")\n        self.board.place_stone(move[0], move[1], self.current_player)\n\n    def show_result(self):\n        black, white = self.board.count_stones()\n        print(\"\\næœ€çµ‚çµæœ\")\n        self.board.print_board()\n        print(f\"é»’:{black} ç™½:{white}\")\n\n        if black > white:\n            print(\"ã‚ãªãŸã®å‹ã¡ï¼\")\n        elif black < white:\n            print(\"CPUã®å‹ã¡\")\n        else:\n            print(\"å¼•ãåˆ†ã‘\")\n\n\n# --- å®Ÿè¡Œ ---\ngame = OthelloGame()\ngame.play()\n"
  },
  {
    "name": "Ibuki",
    "description": "",
    "code": "import random\n\n# =====================\n# Boardã‚¯ãƒ©ã‚¹ï¼ˆç›¤é¢ç®¡ç†ï¼‰\n# =====================\nclass Board:\n    def __init__(self):\n        self.board = [['.' for _ in range(8)] for _ in range(8)]\n        self.board[3][3] = 'O'\n        self.board[4][4] = 'O'\n        self.board[3][4] = 'X'\n        self.board[4][3] = 'X'\n\n    def display(self):\n        print(\"  0 1 2 3 4 5 6 7\")\n        for i, row in enumerate(self.board):\n            print(i, \" \".join(row))\n        print()\n\n    def is_empty(self, x, y):\n        return self.board[x][y] == '.'\n\n    def place(self, x, y, stone):\n        self.board[x][y] = stone\n\n\n# =====================\n# Playerã‚¯ãƒ©ã‚¹\n# =====================\nclass Player:\n    def __init__(self, stone):\n        self.stone = stone\n\n    def move(self, board):\n        pass\n\n\n# =====================\n# ãƒ©ãƒ³ãƒ€ãƒ AI\n# =====================\nclass RandomAI(Player):\n    def move(self, board):\n        candidates = []\n        for i in range(8):\n            for j in range(8):\n                if board.is_empty(i, j):\n                    candidates.append((i, j))\n        return random.choice(candidates)\n\n\n# =====================\n# è©•ä¾¡é–¢æ•°ä»˜ãAIï¼ˆè§’ã‚’é‡è¦–ï¼‰\n# =====================\nclass SmartAI(Player):\n    def move(self, board):\n        best_score = -999\n        best_move = None\n\n        for i in range(8):\n            for j in range(8):\n                if board.is_empty(i, j):\n                    score = self.evaluate(i, j)\n                    if score > best_score:\n                        best_score = score\n                        best_move = (i, j)\n\n        return best_move\n\n    def evaluate(self, x, y):\n        # è§’ã‚’é«˜ãè©•ä¾¡ï¼ˆã‚ªã‚»ãƒ­ã®åŸºæœ¬æˆ¦ç•¥ï¼‰\n        if (x, y) in [(0,0), (0,7), (7,0), (7,7)]:\n            return 10\n        return 1\n\n\n# =====================\n# Gameã‚¯ãƒ©ã‚¹ï¼ˆå¯¾å±€ç®¡ç†ï¼‰\n# =====================\nclass Game:\n    def __init__(self):\n        self.board = Board()\n        self.players = [RandomAI('X'), SmartAI('O')]\n        self.turn = 0\n\n    def play(self, turns=20):\n        self.board.display()\n\n        for t in range(turns):\n            player = self.players[self.turn]\n            x, y = player.move(self.board)\n            self.board.place(x, y, player.stone)\n\n            print(f\"{t+1}æ‰‹ç›®ï¼š {player.stone} ãŒ ({x}, {y}) ã«ç€æ‰‹\")\n            self.board.display()\n\n            self.turn = 1 - self.turn\n\n\n# =====================\n# å®Ÿè¡Œ\n# =====================\ngame = Game()\ngame.play()"
  }
]