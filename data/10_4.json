[
  {
    "name": "Mahiro",
    "description": "8æ–¹å‘ã‚’ã¾ã¨ã‚ã¦ãƒã‚§ãƒƒã‚¯ã§ãã‚‹ã‚ˆã†ã«ã—ã¦ã€çŸ³ãŒè£è¿”ã‚‹åˆ¤å®šã‚’ç°¡æ½”ã«æ›¸ã‘ã‚‹ã‚ˆã†å·¥å¤«ã—ã¾ã—ãŸã€‚",
    "code": "# ======== ã‚ªã‚»ãƒ­ (Reversi) ã‚²ãƒ¼ãƒ  ========\n\nimport numpy as np\n\n# 8x8 ã®ç›¤é¢ã‚’ä½œæˆ\nboard = np.zeros((8, 8), dtype=int)\n\n# åˆæœŸé…ç½®\nboard[3][3], board[4][4] = -1, -1  # ç™½\nboard[3][4], board[4][3] = 1, 1    # é»’\n\n# ç›¤é¢ã‚’è¡¨ç¤º\ndef show_board():\n    print(\"   0 1 2 3 4 5 6 7\")\n    for i in range(8):\n        row = \"\"\n        for j in range(8):\n            if board[i][j] == 1:\n                row += \" B\"\n            elif board[i][j] == -1:\n                row += \" W\"\n            else:\n                row += \" .\"\n        print(i, row)\n\n# çŸ³ã‚’ç½®ã‘ã‚‹ã‹ãƒã‚§ãƒƒã‚¯ï¼ˆè¿”ã›ã‚‹çŸ³ãŒã‚ã‚‹ã‹ï¼‰\ndef valid_moves(player):\n    moves = []\n    directions = [(-1,0),(1,0),(0,-1),(0,1),\n                  (-1,-1),(-1,1),(1,-1),(1,1)]\n\n    for r in range(8):\n        for c in range(8):\n            if board[r][c] != 0:\n                continue\n            for dr, dc in directions:\n                rr, cc = r + dr, c + dc\n                flipped = False\n                count = 0\n                \n                while 0 <= rr < 8 and 0 <= cc < 8:\n                    if board[rr][cc] == -player:\n                        flipped = True\n                        count += 1\n                    elif board[rr][cc] == player and flipped:\n                        moves.append((r, c))\n                        break\n                    else:\n                        break\n                    rr += dr\n                    cc += dc\n    return moves\n\n# çŸ³ã‚’ç½®ã„ã¦è£è¿”ã™å‡¦ç†\ndef place_stone(r, c, player):\n    directions = [(-1,0),(1,0),(0,-1),(0,1),\n                  (-1,-1),(-1,1),(1,-1),(1,1)]\n    \n    board[r][c] = player\n\n    for dr, dc in directions:\n        rr, cc = r + dr, c + dc\n        stones = []\n\n        while 0 <= rr < 8 and 0 <= cc < 8:\n            if board[rr][cc] == -player:\n                stones.append((rr, cc))\n            elif board[rr][cc] == player:\n                for (sr, sc) in stones:\n                    board[sr][sc] = player\n                break\n            else:\n                break\n            rr += dr\n            cc += dc\n\n# ======== ãƒ¡ã‚¤ãƒ³ã‚²ãƒ¼ãƒ  ========\n\nplayer = 1  # 1=é»’  -1=ç™½\n\nwhile True:\n    show_board()\n    print(\"\\né»’(B)=1, ç™½(W)=-1  ç¾åœ¨ã®æ‰‹ç•ªï¼š\", \"é»’(B)\" if player == 1 else \"ç™½(W)\")\n\n    moves = valid_moves(player)\n    if not moves:\n        print(\"ç½®ã‘ã‚‹å ´æ‰€ãŒã‚ã‚Šã¾ã›ã‚“ã€‚ãƒ‘ã‚¹ã—ã¾ã™ã€‚\\n\")\n        player *= -1\n        continue\n\n    print(\"ç½®ã‘ã‚‹å ´æ‰€ï¼š\", moves)\n    \n    # å…¥åŠ› (ä¾‹: \"3 4\" ã®ã‚ˆã†ã«å…¥åŠ›ã™ã‚‹)\n    r, c = map(int, input(\"è¡Œ åˆ— ã‚’å…¥åŠ›ã—ã¦ãã ã•ã„: \").split())\n    \n    if (r, c) in moves:\n        place_stone(r, c, player)\n        player *= -1\n    else:\n        print(\"ãã“ã«ã¯ç½®ã‘ã¾ã›ã‚“ã€‚ã‚„ã‚Šç›´ã—ã¦ãã ã•ã„ã€‚\\n\")"
  },
  {
    "name": "haruka",
    "description": "â€¢\tå¯èª­æ€§é‡è¦–:é–¢æ•°ã‚’å°ã•ãåˆ†å‰²ã—ã€ã‚³ãƒ¡ãƒ³ãƒˆã‚’å¤šæ•°è¨˜è¼‰ã€‚æˆæ¥­(è¬›ç¾©10å›ã¾ã§)ã®çŸ¥è­˜ã§ç†è§£ã—ã‚„ã™ã„æ§‹æˆã€‚ \tâ€¢\tæç”»:matplotlib ã§è¦–è¦šçš„ã«è¦‹ã‚„ã™ã„ç›¤é¢ã‚’è¡¨ç¤º(åˆæ³•æ‰‹ã‚’ç·‘ã®â—ã§è¡¨ç¤ºã€é»’ç™½ã®çŸ³ã€å‰æ‰‹ã‚’èµ¤æ ã§å¼·èª¿)â†’ ã‚¹ã‚¯ã‚·ãƒ§ã«æ˜ ãˆã‚‹ã€‚ \tâ€¢\tAI(ç°¡æ˜“):å…ˆèª­ã¿ãªã—ã®Greedy(æœ€å¤šåè»¢)AIã‚’å®Ÿè£…ã€‚è»½ãã¦ç¢ºå®Ÿã«å‹•ããŸã‚Colabã§ã‚‚å®‰å¿ƒã€‚å°†æ¥ã€ãƒŸãƒ‹ãƒãƒƒã‚¯ã‚¹ç­‰ã«æ‹¡å¼µã—ã‚„ã™ã„è¨­è¨ˆã€‚ \tâ€¢\tdemo_play():æå‡ºç”¨ã«é€”ä¸­ç›¤é¢ã‚’è‡ªå‹•ç”Ÿæˆã™ã‚‹é–¢æ•°ã‚’ç”¨æ„(æ‰‹å‹•ãƒ—ãƒ¬ã‚¤ã—ãªãã¦ã‚‚æå‡ºç‰©ã¨ã—ã¦ä½¿ãˆã‚‹)ã€‚",
    "code": "# Othello (Reversi) â€” Google Colab ã§å‹•ãã‚·ãƒ³ãƒ—ãƒ«å®Ÿè£…\n# ãƒ—ãƒ¬ã‚¤æ–¹æ³•:\n#   play_game() ã‚’å‘¼ã‚“ã§å¯¾å±€ã€‚æ‰‹ã¯ \"d3\" ã®ã‚ˆã†ã«è‹±å­—+æ•°å­—ã§å…¥åŠ›ã™ã‚‹ã‹ã€\n#   \"2 3\" ã®ã‚ˆã†ã«è¡Œåˆ—ã‚’ç©ºç™½ã§æŒ‡å®šã§ãã¾ã™ã€‚\n# ãƒ‡ãƒ¢:\n#   demo_play() ã‚’å‘¼ã¶ã¨è‡ªå‹•ã§æ•°æ‰‹é€²ã‚ãŸç›¤é¢ã‚’è¡¨ç¤ºï¼ˆã‚¹ã‚¯ã‚·ãƒ§ç”¨ï¼‰ã€‚\n\nimport numpy as np\nimport matplotlib.pyplot as plt\nfrom copy import deepcopy\nimport random\n\n# --- åŸºæœ¬è¨­å®š ---\nEMPTY = 0\nBLACK = 1\nWHITE = -1\nBOARD_SIZE = 8\nDIRECTIONS = [(-1,-1),(-1,0),(-1,1),(0,-1),(0,1),(1,-1),(1,0),(1,1)]\n\ndef init_board():\n    \"\"\"åˆæœŸç›¤é¢ã‚’è¿”ã™ï¼ˆ8x8ï¼‰\"\"\"\n    b = np.zeros((BOARD_SIZE, BOARD_SIZE), dtype=int)\n    # ä¸­å¤®4ãƒã‚¹ã«é…ç½®ï¼ˆæ¨™æº–ãƒ«ãƒ¼ãƒ«ï¼‰\n    b[3,3] = WHITE\n    b[3,4] = BLACK\n    b[4,3] = BLACK\n    b[4,4] = WHITE\n    return b\n\n# --- ãƒ¦ãƒ¼ãƒ†ã‚£ãƒªãƒ†ã‚£: åº§æ¨™å¤‰æ›ï¼ˆä¾‹: 'd3' -> (2,3)ï¼‰ ---\ndef parse_move(move_str):\n    \"\"\"'d3' å½¢å¼ ã¾ãŸã¯ 'r c' å½¢å¼ã‚’ (row, col) ã«å¤‰æ›ï¼ˆ0-indexedï¼‰ã€‚å¤±æ•—æ™‚ã¯ None\"\"\"\n    s = move_str.strip().lower()\n    if not s:\n        return None\n    # 'd3' å½¢å¼ï¼ˆletter+numberï¼‰\n    if len(s) >= 2 and s[0].isalpha():\n        col = ord(s[0]) - ord('a')\n        try:\n            row = int(s[1:]) - 1\n        except:\n            return None\n        if 0 <= row < BOARD_SIZE and 0 <= col < BOARD_SIZE:\n            return (row, col)\n        return None\n    # 'r c' å½¢å¼\n    parts = s.split()\n    if len(parts) == 2:\n        try:\n            r = int(parts[0]) - 1\n            c = int(parts[1]) - 1\n        except:\n            return None\n        if 0 <= r < BOARD_SIZE and 0 <= c < BOARD_SIZE:\n            return (r, c)\n    return None\n\n# --- åˆæ³•æ‰‹åˆ¤å®šã¨åè»¢ã•ã‚Œã‚‹çŸ³ã®å–å¾— ---\ndef is_on_board(r, c):\n    return 0 <= r < BOARD_SIZE and 0 <= c < BOARD_SIZE\n\ndef flips_for_move(board, player, r, c):\n    \"\"\"(r,c) ã« player ã®çŸ³ã‚’ç½®ã„ãŸã¨ãã«åè»¢ã™ã‚‹çŸ³ã®ãƒªã‚¹ãƒˆã‚’è¿”ã™ï¼ˆç©ºãªã‚‰åˆæ³•æ‰‹ã§ãªã„ï¼‰\"\"\"\n    if board[r,c] != EMPTY:\n        return []\n    to_flip = []\n    opponent = -player\n    for dr,dc in DIRECTIONS:\n        rr, cc = r + dr, c + dc\n        flips_dir = []\n        while is_on_board(rr, cc) and board[rr,cc] == opponent:\n            flips_dir.append((rr,cc))\n            rr += dr\n            cc += dc\n        if is_on_board(rr,cc) and board[rr,cc] == player and flips_dir:\n            to_flip.extend(flips_dir)\n    return to_flip\n\ndef legal_moves(board, player):\n    \"\"\"playerã®åˆæ³•æ‰‹ãƒªã‚¹ãƒˆ [(r,c), ...] ã‚’è¿”ã™\"\"\"\n    moves = []\n    for r in range(BOARD_SIZE):\n        for c in range(BOARD_SIZE):\n            if flips_for_move(board, player, r, c):\n                moves.append((r,c))\n    return moves\n\ndef apply_move(board, player, r, c):\n    \"\"\"ç›¤é¢ã«æ‰‹ã‚’é©ç”¨ã—ã¦åè»¢å‡¦ç†ã€‚æ–°ã—ã„ç›¤é¢ã‚’è¿”ã™\"\"\"\n    flips = flips_for_move(board, player, r, c)\n    if not flips:\n        return None\n    nb = board.copy()\n    nb[r,c] = player\n    for (fr,fc) in flips:\n        nb[fr,fc] = player\n    return nb\n\ndef score(board):\n    \"\"\"(black_count, white_count)\"\"\"\n    blacks = int(np.sum(board == BLACK))\n    whites = int(np.sum(board == WHITE))\n    return blacks, whites\n\n# --- æç”» ---\ndef draw_board(board, legal=None, last_move=None, title=None, figsize=(6,6)):\n    \"\"\"matplotlibã§ç›¤é¢ã‚’æç”»ã€‚legalã¯åˆæ³•æ‰‹ãƒªã‚¹ãƒˆã€last_moveã¯ãƒã‚¤ãƒ©ã‚¤ãƒˆç”¨\"\"\"\n    if legal is None:\n        legal = []\n    fig, ax = plt.subplots(figsize=figsize)\n    # èƒŒæ™¯ï¼ˆç›¤ï¼‰\n    ax.set_xlim(-0.5, BOARD_SIZE-0.5)\n    ax.set_ylim(-0.5, BOARD_SIZE-0.5)\n    ax.set_xticks(np.arange(0, BOARD_SIZE))\n    ax.set_yticks(np.arange(0, BOARD_SIZE))\n    ax.set_xticklabels([chr(ord('a')+i) for i in range(BOARD_SIZE)])\n    ax.set_yticklabels([str(i+1) for i in range(BOARD_SIZE)])\n    ax.grid(True, linewidth=1)\n    ax.set_aspect('equal')\n    # çŸ³ã‚’æã\n    for r in range(BOARD_SIZE):\n        for c in range(BOARD_SIZE):\n            v = board[r,c]\n            if v == BLACK or v == WHITE:\n                circle = plt.Circle((c, BOARD_SIZE-1-r), 0.4, color='black' if v==BLACK else 'white', ec='black')\n                ax.add_patch(circle)\n    # åˆæ³•æ‰‹ã‚’ç·‘ä¸¸ã§è¡¨ç¤º\n    for (r,c) in legal:\n        circ = plt.Circle((c, BOARD_SIZE-1-r), 0.12, color='green', alpha=0.6)\n        ax.add_patch(circ)\n    # æœ€å¾Œã®æ‰‹ã‚’èµ¤æ ã§è¡¨ç¤º\n    if last_move is not None:\n        lr, lc = last_move\n        rect = plt.Rectangle((lc-0.45, BOARD_SIZE-1-lr-0.45), 0.9, 0.9, fill=False, lw=2, edgecolor='red')\n        ax.add_patch(rect)\n    # ã‚¹ã‚³ã‚¢è¡¨ç¤º\n    b,w = score(board)\n    ax.set_title(f\"{title or 'Othello'} â€” Black: {b}  White: {w}\")\n    plt.gca().invert_yaxis()\n    plt.show()\n\n# --- ã‚·ãƒ³ãƒ—ãƒ«AIï¼ˆGreedy: æœ€ã‚‚å¤šãåè»¢ã™ã‚‹æ‰‹ã‚’é¸ã¶ï¼‰ ---\ndef greedy_ai_move(board, player):\n    moves = legal_moves(board, player)\n    if not moves:\n        return None\n    best = None\n    best_flips = -1\n    for (r,c) in moves:\n        f = len(flips_for_move(board, player, r, c))\n        if f > best_flips:\n            best_flips = f\n            best = (r,c)\n    return best\n\n# --- ã‚²ãƒ¼ãƒ ãƒ«ãƒ¼ãƒ—ï¼ˆäººé–“ vs AIï¼‰ ---\ndef play_game(human_color=BLACK, ai_func=greedy_ai_move, auto_demo=False):\n    \"\"\"\n    human_color: BLACK or WHITEï¼ˆäººé–“ãŒã©ã¡ã‚‰ã®è‰²ã‚’æ‹…å½“ã™ã‚‹ã‹ï¼‰\n    ai_func: AIã®æ‰‹ã‚’æ±ºã‚ã‚‹é–¢æ•° (board, player) -> (r,c) or None\n    auto_demo: True ã®ã¨ãã¯è‡ªå‹•ã§æ•°æ‰‹é€²ã‚ã¦æˆ»ã‚‹ï¼ˆãƒ‡ãƒ¢ç”¨ï¼‰\n    \"\"\"\n    board = init_board()\n    player = BLACK  # é»’ã‹ã‚‰é–‹å§‹\n    last_move = None\n    passes = 0\n\n    # ç°¡æ˜“ãƒ˜ãƒ«ãƒ‘ãƒ¼: è¡¨ç¤ºã¨å…¥åŠ›å‡¦ç†\n    def show():\n        lm = last_move\n        L = legal_moves(board, player if player==human_color else player)\n        draw_board(board, legal=L, last_move=lm, title=f\"Turn: {'Black' if player==BLACK else 'White'}\")\n    \n    if auto_demo:\n        # ãƒ‡ãƒ¢é€²è¡Œ: AIåŒå£«ã§ãƒ©ãƒ³ãƒ€ãƒ orgreedyã«æ•°æ‰‹é€²ã‚ã‚‹ï¼ˆæå‡ºç”¨ã®é€”ä¸­ç›¤é¢ï¼‰\n        turns = 12  # é©åº¦ã«é€²ã‚ã‚‹\n        for t in range(turns):\n            moves = legal_moves(board, player)\n            if moves:\n                # äº¤äº’ã« greedy ã¨ random ã‚’ä½¿ã£ã¦ã»ã©ã‚ˆã„ç›¤é¢ã«ã™ã‚‹\n                if player == BLACK:\n                    mv = greedy_ai_move(board, player)\n                else:\n                    mv = random.choice(moves)\n                board = apply_move(board, player, mv[0], mv[1])\n                last_move = mv\n                passes = 0\n            else:\n                passes += 1\n                if passes >= 2:\n                    break\n            player = -player\n        draw_board(board, legal=legal_moves(board, human_color), last_move=last_move,\n                   title=\"Demo midgame (use this for screenshot)\")\n        return board\n\n    # å¯¾å±€ï¼ˆäººé–“ vs AIï¼‰\n    while True:\n        moves = legal_moves(board, player)\n        if not moves:\n            passes += 1\n            if passes >= 2:\n                # ä¸¡è€…ãƒ‘ã‚¹ã§çµ‚äº†\n                b,w = score(board)\n                draw_board(board, legal=[], last_move=last_move, title=\"Game Over\")\n                print(\"Game over.\")\n                print(f\"Final score â€” Black: {b}  White: {w}\")\n                if b > w:\n                    print(\"Black wins!\")\n                elif w > b:\n                    print(\"White wins!\")\n                else:\n                    print(\"Draw.\")\n                return board\n            else:\n                # ãƒ‘ã‚¹ã—ã¦ç›¸æ‰‹ã«ç§»è¡Œ\n                print(f\"{'Black' if player==BLACK else 'White'} has no legal moves and passes.\")\n                player = -player\n                continue\n        else:\n            passes = 0\n\n        # è¡¨ç¤º\n        draw_board(board, legal=moves, last_move=last_move, title=f\"Turn: {'Black' if player==BLACK else 'White'}\")\n\n        if player == human_color:\n            # äººé–“ã®æ‰‹\n            raw = input(f\"Your move (you are {'Black' if human_color==BLACK else 'White'}). Enter (e.g. d3 or 'r c'): \")\n            mv = parse_move(raw)\n            if mv is None:\n                print(\"å…¥åŠ›ãŒä¸æ­£ã§ã™ã€‚å†å…¥åŠ›ã—ã¦ãã ã•ã„ã€‚ (e.g. d3 ã¾ãŸã¯ 3 4)\")\n                continue\n            if (mv[0], mv[1]) not in moves:\n                print(\"ãã®æ‰‹ã¯åˆæ³•ã§ã¯ã‚ã‚Šã¾ã›ã‚“ã€‚åˆæ³•æ‰‹:\", [(r+1,c+1) for r,c in moves])\n                continue\n            board = apply_move(board, player, mv[0], mv[1])\n            last_move = mv\n        else:\n            # AIã®æ‰‹\n            mv = ai_func(board, player)\n            if mv is None:\n                # ä¸‡ãŒä¸€AIãŒNoneã‚’è¿”ã—ãŸã¨ãã¯ãƒ©ãƒ³ãƒ€ãƒ ã§\n                mv = random.choice(moves)\n            print(f\"AI ({'Black' if player==BLACK else 'White'}) plays: {chr(ord('a')+mv[1])}{mv[0]+1}\")\n            board = apply_move(board, player, mv[0], mv[1])\n            last_move = mv\n        player = -player\n\n# --- ãƒ‡ãƒ¢é–¢æ•°ï¼ˆé€”ä¸­ç›¤é¢ã‚’ç”Ÿæˆã—ã¦è¡¨ç¤ºï¼‰ ---\ndef demo_play():\n    \"\"\"ãƒ‡ãƒ¢ç”¨ã«æ•°æ‰‹é€²ã‚ãŸç›¤é¢ã‚’è¡¨ç¤ºï¼ˆã‚¹ã‚¯ã‚·ãƒ§æå‡ºç”¨ã«ä¾¿åˆ©ï¼‰\"\"\"\n    play_game(auto_demo=True)\n\n# --- è¿½åŠ : åˆ¥ã®ç°¡æ˜“AIï¼ˆãƒ©ãƒ³ãƒ€ãƒ ï¼‰ ---\ndef random_ai_move(board, player):\n    moves = legal_moves(board, player)\n    if not moves:\n        return None\n    return random.choice(moves)\n\n# --- ä½¿ã„æ–¹ä¾‹ï¼ˆColabã§ã‚»ãƒ«ã‚’å®Ÿè¡Œã—ãŸã¨ãã«ã™ããƒ‡ãƒ¢ã‚’è¡¨ç¤ºã—ãŸã‘ã‚Œã°ä¸‹ã‚’æœ‰åŠ¹åŒ–ï¼‰ ---\nif __name__ == \"__main__\":\n    print(\"ã“ã®ã‚¹ã‚¯ãƒªãƒ—ãƒˆã‚’ç›´æ¥å®Ÿè¡Œã—ã¾ã—ãŸã€‚demo_play() ã‚’å‘¼ã‚“ã§é€”ä¸­ç›¤é¢ã‚’è¡¨ç¤ºã§ãã¾ã™ã€‚\")\n    # demo_play()  # ã‚³ãƒ¡ãƒ³ãƒˆã‚’å¤–ã™ã¨è‡ªå‹•ã§ãƒ‡ãƒ¢ã‚’è¡¨ç¤ºã—ã¾ã™"
  },
  {
    "name": "Motonobu",
    "description": "Google Colab ã§å‹•ä½œã™ã‚‹ ãƒ†ã‚­ã‚¹ãƒˆãƒ™ãƒ¼ã‚¹ã®ã‚ªã‚»ãƒ­(ãƒªãƒãƒ¼ã‚·)ã‚²ãƒ¼ãƒ ã€‚ ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã¯é»’(X)ã€ç™½(O)ã‚’äº¤äº’ã«å…¥åŠ›ã—ã¦ã‚²ãƒ¼ãƒ ã‚’é€²ã‚ã‚‹ã€‚",
    "code": "# --- ã‚ªã‚»ãƒ­ï¼ˆãƒªãƒãƒ¼ã‚·ï¼‰ã‚²ãƒ¼ãƒ ï¼šãƒ†ã‚­ã‚¹ãƒˆç‰ˆ ---\n# Google Colab ä¸Šã§ãã®ã¾ã¾å‹•ä½œã™ã‚‹ç°¡æ˜“ç‰ˆ\n# äººé–“ vs äººé–“ (é»’ = X, ç™½ = O)\n\n# ç›¤ã‚µã‚¤ã‚ºï¼ˆé€šå¸¸8x8ï¼‰\nSIZE = 8\n\n# ç›¤é¢ã®åˆæœŸåŒ–\ndef init_board():\n    board = [[\".\" for _ in range(SIZE)] for _ in range(SIZE)]\n    mid = SIZE // 2\n    board[mid-1][mid-1] = \"O\"\n    board[mid][mid]     = \"O\"\n    board[mid-1][mid]   = \"X\"\n    board[mid][mid-1]   = \"X\"\n    return board\n\n# ç›¤é¢è¡¨ç¤º\ndef print_board(board):\n    print(\"   \" + \" \".join(str(i) for i in range(SIZE)))\n    for i, row in enumerate(board):\n        print(f\"{i}  \" + \" \".join(row))\n    print()\n\n# ã‚ã‚‹ä½ç½®ãŒç›¤é¢å†…ã‹ãƒã‚§ãƒƒã‚¯\ndef on_board(x, y):\n    return 0 <= x < SIZE and 0 <= y < SIZE\n\n# åˆæ³•æ‰‹ã®åˆ¤å®šï¼ˆç½®ã‘ã‚‹ã‹ã©ã†ã‹ã€ã²ã£ãã‚Šè¿”ã‚‹çŸ³ã‚’è¿”ã™ï¼‰\ndef get_flips(board, x, y, color):\n    if board[x][y] != \".\":\n        return []  # ç©ºããƒã‚¹ã§ãªã‘ã‚Œã°ç½®ã‘ãªã„\n\n    opponent = \"O\" if color == \"X\" else \"X\"\n    flips = []\n\n    # 8æ–¹å‘ã‚’ãƒã‚§ãƒƒã‚¯\n    directions = [\n        (1,0), (-1,0), (0,1), (0,-1),\n        (1,1), (1,-1), (-1,1), (-1,-1)\n    ]\n\n    for dx, dy in directions:\n        nx, ny = x + dx, y + dy\n        path = []\n\n        # ç›¸æ‰‹ã®çŸ³ã‚’ãŸã©ã‚‹\n        while on_board(nx, ny) and board[nx][ny] == opponent:\n            path.append((nx, ny))\n            nx += dx\n            ny += dy\n\n        # ãã®å…ˆãŒè‡ªåˆ†ã®çŸ³ãªã‚‰åˆæ³•ï¼ˆã²ã£ãã‚Šè¿”ã™çŸ³ãŒã‚ã‚‹ï¼‰\n        if on_board(nx, ny) and board[nx][ny] == color and len(path) > 0:\n            flips.extend(path)\n\n    return flips\n\n# åˆæ³•æ‰‹ä¸€è¦§å–å¾—\ndef valid_moves(board, color):\n    moves = []\n    for i in range(SIZE):\n        for j in range(SIZE):\n            if len(get_flips(board, i, j, color)) > 0:\n                moves.append((i, j))\n    return moves\n\n# ãƒ¡ã‚¤ãƒ³ã‚²ãƒ¼ãƒ ãƒ«ãƒ¼ãƒ—\ndef play_game():\n    board = init_board()\n    current = \"X\"  # é»’ã‹ã‚‰ã‚¹ã‚¿ãƒ¼ãƒˆ\n\n    while True:\n        print_board(board)\n        moves = valid_moves(board, current)\n\n        if not moves:\n            # ç›¸æ‰‹ã‚‚æ‰“ã¦ãªã‘ã‚Œã°çµ‚äº†\n            opponent = \"O\" if current == \"X\" else \"X\"\n            if not valid_moves(board, opponent):\n                print(\"ã©ã¡ã‚‰ã‚‚æ‰“ã¦ãªã„ãŸã‚çµ‚äº†ï¼\")\n                break\n            else:\n                print(f\"{current} ã¯æ‰“ã¦ã‚‹å ´æ‰€ãŒã‚ã‚Šã¾ã›ã‚“ã€‚ãƒ‘ã‚¹ï¼\")\n                current = opponent\n                continue\n\n        print(f\"ç¾åœ¨ã®æ‰‹ç•ªï¼š {current}\")\n        print(\"åˆæ³•æ‰‹ï¼š\", moves)\n\n        # å…¥åŠ›å—ä»˜\n        try:\n            x = int(input(\"è¡Œ (0-7): \"))\n            y = int(input(\"åˆ— (0-7): \"))\n        except:\n            print(\"æ•°å­—ã‚’å…¥åŠ›ã—ã¦ãã ã•ã„ã€‚\")\n            continue\n\n        flips = get_flips(board, x, y, current)\n        if len(flips) == 0:\n            print(\"ãã“ã«ã¯ç½®ã‘ã¾ã›ã‚“ã€‚\")\n            continue\n\n        # çŸ³ã‚’ç½®ã\n        board[x][y] = current\n        for fx, fy in flips:\n            board[fx][fy] = current\n\n        # æ‰‹ç•ªäº¤ä»£\n        current = \"O\" if current == \"X\" else \"X\"\n\n    # --- ã‚²ãƒ¼ãƒ çµ‚äº† ---\n    print_board(board)\n    x_count = sum(row.count(\"X\") for row in board)\n    o_count = sum(row.count(\"O\") for row in board)\n    print(f\"é»’ (X): {x_count} å€‹, ç™½ (O): {o_count} å€‹\")\n    if x_count > o_count:\n        print(\"é»’ã®å‹ã¡ï¼\")\n    elif o_count > x_count:\n        print(\"ç™½ã®å‹ã¡ï¼\")\n    else:\n        print(\"å¼•ãåˆ†ã‘ï¼\")\n\n# --- å®Ÿè¡Œ ---\nplay_game()\n"
  },
  {
    "name": "Hitoshi",
    "description": "8âœ–ï¸8ã®ãƒã‚¹ã®ç›¤é¢åŒ–ã‚’åˆæœŸåŒ–ã—ã¦ã„ã‚‹ã€‚é»’ã¨ç™½ã‚’äº¤äº’ã«æ‰“ã¤ã€æœ€åˆã«å¯¾äººå¯¾æˆ¦ã‹aiã‹ã‚’é¸æŠã™ã‚‹ã“ã¨ãŒã§ãã‚‹",
    "code": "#!/usr/bin/env python3\n# othello.py -- ã‚·ãƒ³ãƒ—ãƒ«ãªã‚¿ãƒ¼ãƒŸãƒŠãƒ«ç‰ˆã‚ªã‚»ãƒ­ï¼ˆãƒªãƒãƒ¼ã‚·ï¼‰\n# å¯¾æˆ¦: äºº vs äººã€ã¾ãŸã¯ äºº vs ãƒ©ãƒ³ãƒ€ãƒ AI\n\nimport random\nimport sys\n\nSIZE = 8\nEMPTY = '.'\nBLACK = 'B'\nWHITE = 'W'\nDIRS = [(-1,-1),(-1,0),(-1,1),(0,-1),(0,1),(1,-1),(1,0),(1,1)]\n\ndef init_board():\n    board = [[EMPTY]*SIZE for _ in range(SIZE)]\n    mid = SIZE//2\n    board[mid-1][mid-1] = WHITE\n    board[mid][mid] = WHITE\n    board[mid-1][mid] = BLACK\n    board[mid][mid-1] = BLACK\n    return board\n\ndef print_board(board):\n    cols = 'abcdefgh'\n    print('  ' + ' '.join(cols[:SIZE]))\n    for r in range(SIZE):\n        print(f\"{r+1:2}\" + ' ' + ' '.join(board[r]))\n    b,w = count_pieces(board)\n    print(f\"Score -> B: {b}  W: {w}\")\n\ndef on_board(r,c):\n    return 0 <= r < SIZE and 0 <= c < SIZE\n\ndef opponent(color):\n    return BLACK if color==WHITE else WHITE\n\ndef valid_moves(board, color):\n    moves = {}\n    opp = opponent(color)\n    for r in range(SIZE):\n        for c in range(SIZE):\n            if board[r][c] != EMPTY:\n                continue\n            flips = []\n            for dr,dc in DIRS:\n                rr,cc = r+dr, c+dc\n                flip_candidates = []\n                while on_board(rr,cc) and board[rr][cc] == opp:\n                    flip_candidates.append((rr,cc))\n                    rr += dr; cc += dc\n                if on_board(rr,cc) and board[rr][cc] == color and flip_candidates:\n                    flips.extend(flip_candidates)\n            if flips:\n                moves[(r,c)] = flips\n    return moves  # dict: (r,c) -> list of flips\n\ndef make_move(board, color, move, flips):\n    r,c = move\n    board[r][c] = color\n    for rr,cc in flips:\n        board[rr][cc] = color\n\ndef count_pieces(board):\n    b = sum(row.count(BLACK) for row in board)\n    w = sum(row.count(WHITE) for row in board)\n    return b,w\n\ndef parse_move(s):\n    s = s.strip().lower()\n    if s == 'pass':\n        return 'pass'\n    if len(s) < 2: return None\n    col = s[0]\n    row = s[1:]\n    if not ('a' <= col <= 'h'): return None\n    try:\n        r = int(row)-1\n    except:\n        return None\n    c = ord(col) - ord('a')\n    if not on_board(r,c): return None\n    return (r,c)\n\ndef choose_ai_move(moves):\n    # éå¸¸ã«å˜ç´”ãªãƒ©ãƒ³ãƒ€ãƒ AIï¼ˆæ”¹è‰¯å¯ï¼‰\n    return random.choice(list(moves.items()))  # returns ((r,c), flips)\n\ndef game_loop(vs_ai=False, ai_color=WHITE):\n    board = init_board()\n    turn = BLACK  # Black starts\n    consecutive_passes = 0\n\n    while True:\n        print()\n        print_board(board)\n        moves = valid_moves(board, turn)\n        if not moves:\n            print(f\"{turn} ã®åˆæ³•æ‰‹ãªã— -> ãƒ‘ã‚¹ (pass)\")\n            consecutive_passes += 1\n            if consecutive_passes >= 2:\n                print(\"ä¸¡è€…ãƒ‘ã‚¹ã®ãŸã‚çµ‚äº†ã—ã¾ã™ã€‚\")\n                break\n            turn = opponent(turn)\n            continue\n        consecutive_passes = 0\n\n        if vs_ai and turn == ai_color:\n            # AI ã®æ‰‹\n            (move, flips) = choose_ai_move(moves)\n            make_move(board, turn, move, flips)\n            col = chr(ord('a') + move[1])\n            row = move[0] + 1\n            print(f\"AI({turn}) -> {col}{row}\")\n        else:\n            # äººé–“ã®å…¥åŠ›\n            while True:\n                prompt = f\"{turn} ã®æ‰‹ã‚’å…¥åŠ› ({'a1'+'ã€œ'+'h8'} / pass): \"\n                s = input(prompt).strip()\n                parsed = parse_move(s)\n                if parsed == 'pass':\n                    print(f\"{turn} ãŒãƒ‘ã‚¹ã—ã¾ã—ãŸã€‚\")\n                    break\n                if parsed is None:\n                    print(\"å…¥åŠ›ãŒç„¡åŠ¹ã§ã™ã€‚ä¾‹: d3 ã¾ãŸã¯ pass\")\n                    continue\n                if parsed not in moves:\n                    print(\"ãã®æ‰‹ã¯åˆæ³•æ‰‹ã§ã¯ã‚ã‚Šã¾ã›ã‚“ã€‚åˆæ³•æ‰‹ã®ä¸€è¦§:\")\n                    # è¡¨ç¤º: a3, ...\n                    legal = [f\"{chr(ord('a')+c)}{r+1}\" for (r,c) in moves.keys()]\n                    print(', '.join(sorted(legal)))\n                    continue\n                make_move(board, turn, parsed, moves[parsed])\n                break\n\n        turn = opponent(turn)\n\n        # çµ‚äº†åˆ¤å®š: ç›¤ãŒåŸ‹ã¾ã£ãŸã‚‰çµ‚äº†\n        total = sum(row.count(EMPTY) for row in board)\n        if total == 0:\n            print(\"ç›¤ãŒåŸ‹ã¾ã‚Šã¾ã—ãŸã€‚ã‚²ãƒ¼ãƒ çµ‚äº†ã€‚\")\n            break\n\n    b,w = count_pieces(board)\n    print_board(board)\n    print(\"æœ€çµ‚çµæœ:\")\n    print(f\"Black (B): {b}  White (W): {w}\")\n    if b > w:\n        print(\"å‹è€…: Black (B)\")\n    elif w > b:\n        print(\"å‹è€…: White (W)\")\n    else:\n        print(\"å¼•ãåˆ†ã‘\")\n\ndef main():\n    print(\"=== ã‚ªã‚»ãƒ­ï¼ˆãƒªãƒãƒ¼ã‚·ï¼‰ ===\")\n    print(\"1: äºº vs äºº\")\n    print(\"2: äºº vs AIï¼ˆãƒ©ãƒ³ãƒ€ãƒ ï¼‰\")\n    mode = input(\"ãƒ¢ãƒ¼ãƒ‰ã‚’é¸ã‚“ã§ãã ã•ã„ (1/2): \").strip()\n    if mode == '2':\n        # å…ˆæ‰‹/å¾Œæ‰‹é¸æŠ\n        choice = input(\"ã‚ãªãŸã¯å…ˆæ‰‹(B)ã«ã—ã¾ã™ã‹ï¼Ÿ (y: å…ˆæ‰‹(B) / n: å¾Œæ‰‹(W)) [y/n]: \").strip().lower()\n        if choice == 'y' or choice == 'yes' or choice == 'j':\n            vs_ai = True\n            ai_color = WHITE\n        else:\n            vs_ai = True\n            ai_color = BLACK\n        print(\"ã‚²ãƒ¼ãƒ é–‹å§‹ã€‚åº§æ¨™ä¾‹: d3 å½¢å¼ã€‚ãƒ‘ã‚¹ã¯ 'pass' ã¨å…¥åŠ›ã€‚\")\n        game_loop(vs_ai=vs_ai, ai_color=ai_color)\n    else:\n        print(\"äºº vs äºº ãƒ¢ãƒ¼ãƒ‰ã€‚ã‚²ãƒ¼ãƒ é–‹å§‹ã€‚åº§æ¨™ä¾‹: d3 å½¢å¼ã€‚ãƒ‘ã‚¹ã¯ 'pass' ã¨å…¥åŠ›ã€‚\")\n        game_loop(vs_ai=False)\n\nif __name__ == '__main__':\n    try:\n        main()\n    except KeyboardInterrupt:\n        print(\"\\nçµ‚äº†ã—ã¾ã—ãŸã€‚\")\n        sys.exit(0)"
  },
  {
    "name": "Hayate",
    "description": "8Ã—8ã®ç›¤é¢ã‚’ãƒªã‚¹ãƒˆã§ç®¡ç†ã—ã€ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ãŒå…¥åŠ›ã—ãŸåº§æ¨™ã«çŸ³ã‚’ç½®ã‘ã‚‹ã‹ã©ã†ã‹ã‚’åˆ¤å®šã—ã¦ã‹ã‚‰å‡¦ç†ã‚’è¡Œã„ã¾ã™ã€‚å·¥å¤«ã—ãŸç‚¹ã¯ã€ä¸Šä¸‹å·¦å³ã ã‘ã§ãªãæ–œã‚æ–¹å‘ã‚‚åˆ¤å®šã§ãã‚‹ã‚ˆã†ã«ã—ãŸç‚¹ã¨ã€é»’ã¨ç™½ã®çŸ³ã‚’è‰²ä»˜ãã§è¡¨ç¤ºã—ã¦è¦‹ã‚„ã™ãã—ãŸç‚¹ã§ã™ã€‚ã¾ãŸã€ç½®ã‘ã‚‹å ´æ‰€ãŒãªã„å ´åˆã¯è‡ªå‹•ã§ãƒ‘ã‚¹ã—ã€ä¸¡è€…ã¨ã‚‚ã«æ‰“ã¦ãªããªã£ãŸæ™‚ç‚¹ã§ã‚²ãƒ¼ãƒ ãŒçµ‚äº†ã™ã‚‹ã‚ˆã†ã«ã—ã¾ã—ãŸã€‚",
    "code": "# çŸ³ã®å®šç¾©\nEMPTY = \".\"\nBLACK = \"â—\"\nWHITE = \"â—‹\"\n\n# 8x8 ã®ç›¤é¢ã‚’ä½œæˆ\ndef create_board():\n    board = [[EMPTY for _ in range(8)] for _ in range(8)]\n    # åˆæœŸé…ç½®\n    board[3][3] = WHITE\n    board[3][4] = BLACK\n    board[4][3] = BLACK\n    board[4][4] = WHITE\n    return board\n\n# ç›¤é¢ã‚’è¡¨ç¤ºï¼ˆè‰²ä»˜ãï¼‰\ndef print_board(board):\n    print(\"  0 1 2 3 4 5 6 7\")\n    for i in range(8):\n        print(i, end=\" \")\n        for j in range(8):\n            cell = board[i][j]\n            if cell == BLACK:\n                print(\"\\033[30mâ—\\033[0m\", end=\" \")\n            elif cell == WHITE:\n                print(\"\\033[37mâ—‹\\033[0m\", end=\" \")\n            else:\n                print(\". \", end=\"\")\n        print()\n    print()\n\n# ã²ã£ãã‚Šè¿”ã™æ–¹å‘\nDIRECTIONS = [\n    (-1, -1), (-1, 0), (-1, 1),\n    (0, -1),          (0, 1),\n    (1, -1),  (1, 0), (1, 1)\n]\n\n# ç›¤é¢ã®ç¯„å›²å†…ã‹ç¢ºèª\ndef in_bounds(x, y):\n    return 0 <= x < 8 and 0 <= y < 8\n\n# ã²ã£ãã‚Šè¿”ã›ã‚‹ã‹ãƒã‚§ãƒƒã‚¯\ndef can_flip(board, x, y, player, dx, dy):\n    opponent = WHITE if player == BLACK else BLACK\n    x += dx\n    y += dy\n    if not in_bounds(x, y) or board[x][y] != opponent:\n        return False\n\n    while in_bounds(x, y):\n        if board[x][y] == EMPTY:\n            return False\n        if board[x][y] == player:\n            return True\n        x += dx\n        y += dy\n    return False\n\n# ãã“ã«ç½®ã‘ã‚‹ã‹ãƒã‚§ãƒƒã‚¯\ndef is_valid_move(board, x, y, player):\n    if board[x][y] != EMPTY:\n        return False\n    for dx, dy in DIRECTIONS:\n        if can_flip(board, x, y, player, dx, dy):\n            return True\n    return False\n\n# çŸ³ã‚’ã²ã£ãã‚Šè¿”ã™\ndef flip_stones(board, x, y, player):\n    for dx, dy in DIRECTIONS:\n        if can_flip(board, x, y, player, dx, dy):\n            cx, cy = x + dx, y + dy\n            while board[cx][cy] != player:\n                board[cx][cy] = player\n                cx += dx\n                cy += dy\n\n# ç½®ã‘ã‚‹å ´æ‰€ãŒã‚ã‚‹ã‹ ç¢ºèª\ndef has_valid_moves(board, player):\n    for i in range(8):\n        for j in range(8):\n            if is_valid_move(board, i, j, player):\n                return True\n    return False\n\n# çŸ³ã®æ•°ã‚’æ•°ãˆã‚‹\ndef count_stones(board):\n    black = 0\n    white = 0\n    for row in board:\n        for cell in row:\n            if cell == BLACK:\n                black += 1\n            elif cell == WHITE:\n                white += 1\n    return black, white\n\n# ===== ã‚²ãƒ¼ãƒ æœ¬ä½“ =====\ndef play_game():\n    board = create_board()\n    current_player = BLACK\n\n    while True:\n        print_board(board)\n        black_count, white_count = count_stones(board)\n        print(f\"é»’(â—): {black_count}  ç™½(â—‹): {white_count}\")\n\n        if not has_valid_moves(board, current_player):\n            print(\"ç½®ã‘ã‚‹å ´æ‰€ãŒãªã„ã®ã§ãƒ‘ã‚¹ã—ã¾ã™ã€‚\")\n            current_player = WHITE if current_player == BLACK else BLACK\n\n            if not has_valid_moves(board, current_player):\n                print(\"ä¸¡è€…ã¨ã‚‚ç½®ã‘ãªã„ãŸã‚ã€ã‚²ãƒ¼ãƒ çµ‚äº†ï¼\")\n                break\n            continue\n\n        print(f\"{'é»’(â—)' if current_player == BLACK else 'ç™½(â—‹)'} ã®ç•ªã§ã™ã€‚\")\n        try:\n            x = int(input(\"è¡Œ (0-7) ã‚’å…¥åŠ›: \"))\n            y = int(input(\"åˆ— (0-7) ã‚’å…¥åŠ›: \"))\n        except:\n            print(\"æ•°å­—ã‚’å…¥åŠ›ã—ã¦ãã ã•ã„ã€‚\")\n            continue\n\n        if not in_bounds(x, y) or not is_valid_move(board, x, y, current_player):\n            print(\"ãã“ã«ã¯ç½®ã‘ã¾ã›ã‚“ã€‚ã‚‚ã†ä¸€åº¦å…¥åŠ›ã—ã¦ãã ã•ã„ã€‚\")\n            continue\n\n        board[x][y] = current_player\n        flip_stones(board, x, y, current_player)\n\n        # æ‰‹ç•ªäº¤ä»£\n        current_player = WHITE if current_player == BLACK else BLACK\n\n    # æœ€çµ‚çµæœ\n    print_board(board)\n    black_count, white_count = count_stones(board)\n    print(\"æœ€çµ‚çµæœ\")\n    print(f\"é»’(â—): {black_count}  ç™½(â—‹): {white_count}\")\n\n    if black_count > white_count:\n        print(\"é»’ã®å‹ã¡ï¼\")\n    elif white_count > black_count:\n        print(\"ç™½ã®å‹ã¡ï¼\")\n    else:\n        print(\"å¼•ãåˆ†ã‘ï¼\")\n\n# å®Ÿè¡Œ\nplay_game()"
  },
  {
    "name": "hirobe",
    "description": "ã“ã®ãƒ—ãƒ­ã‚°ãƒ©ãƒ ã¯ Google Colab ä¸Šã§å‹•ä½œã™ã‚‹ã‚³ãƒ³ã‚½ãƒ¼ãƒ«å‹ã®ã‚ªã‚»ãƒ­(ãƒªãƒãƒ¼ã‚·)ã‚²ãƒ¼ãƒ ã§ã™ã€‚ 8Ã—8 ã®ç›¤é¢ã‚’äºŒæ¬¡å…ƒãƒªã‚¹ãƒˆã§ç®¡ç†ã—ã€åˆæ³•æ‰‹ã®åˆ¤å®šãƒ»çŸ³ã®åè»¢ãƒ»ã‚¿ãƒ¼ãƒ³ç®¡ç†ã‚’ã™ã¹ã¦ Python ã§å®Ÿè£…ã—ã¦ã„ã¾ã™ã€‚  å·¥å¤«ã—ãŸç‚¹:  åˆæ³•æ‰‹ã®æ¢ç´¢ã¨çŸ³ã®åè»¢å‡¦ç†ã‚’é–¢æ•°åŒ–ã—ã€ä»Šå¾Œæ©Ÿèƒ½è¿½åŠ (AI è‡ªå‹•æ‰‹ã‚„è©•ä¾¡é–¢æ•°ãªã©)ãŒã—ã‚„ã™ã„æ§‹é€ ã«ã—ãŸã€‚  æ¯ã‚¿ãƒ¼ãƒ³ç›¤é¢ã‚’ãã‚Œã„ã«å‡ºåŠ›ã™ã‚‹ã“ã¨ã§ã‚¹ã‚¯ãƒªãƒ¼ãƒ³ã‚·ãƒ§ãƒƒãƒˆãŒæ’®ã‚Šã‚„ã™ããªã‚‹ã‚ˆã†ã«ã—ãŸã€‚  ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ãŒç½®ã‘ãªã„å ´åˆã¯è‡ªå‹•ã§ãƒ‘ã‚¹ã™ã‚‹ã‚ˆã†ã«ã—ã¦ã‚ã‚‹ã€‚",
    "code": "# ======== Othello / Reversi Console Game for Google Colab ========\n# ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼1 = é»’ï¼ˆBï¼‰\n# ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼2 = ç™½ï¼ˆWï¼‰\n\nimport copy\n\nEMPTY = \".\"\nBLACK = \"B\"\nWHITE = \"W\"\n\n# åˆæœŸç›¤é¢ã®ç”Ÿæˆ\ndef new_board():\n    board = [[EMPTY]*8 for _ in range(8)]\n    board[3][3] = WHITE\n    board[4][4] = WHITE\n    board[3][4] = BLACK\n    board[4][3] = BLACK\n    return board\n\n# ç›¤é¢ã®è¡¨ç¤º\ndef print_board(board):\n    print(\"  0 1 2 3 4 5 6 7\")\n    for i, row in enumerate(board):\n        print(i, \" \".join(row))\n    print()\n\n# æ–¹å‘ï¼ˆ8æ–¹å‘ï¼‰\nDIRECTIONS = [\n    (-1, -1), (-1, 0), (-1, 1),\n    (0, -1),          (0, 1),\n    (1, -1),  (1, 0), (1, 1)\n]\n\n# åˆæ³•æ‰‹ã®åˆ¤å®šã¨è£è¿”ã™çŸ³ã®ãƒªã‚¹ãƒˆã‚’è¿”ã™\ndef get_flips(board, x, y, color):\n    if board[x][y] != EMPTY:\n        return []\n\n    opponent = WHITE if color == BLACK else BLACK\n    flips = []\n\n    for dx, dy in DIRECTIONS:\n        nx, ny = x + dx, y + dy\n        line = []\n\n        while 0 <= nx < 8 and 0 <= ny < 8 and board[nx][ny] == opponent:\n            line.append((nx, ny))\n            nx += dx\n            ny += dy\n\n        # é€£ç¶šã®å…ˆãŒè‡ªåˆ†ã®è‰²ãªã‚‰ãã® line ã¯è£è¿”ã›ã‚‹\n        if 0 <= nx < 8 and 0 <= ny < 8 and board[nx][ny] == color:\n            flips.extend(line)\n\n    return flips\n\n# åˆæ³•æ‰‹ãƒªã‚¹ãƒˆã‚’å–å¾—\ndef valid_moves(board, color):\n    moves = []\n    for x in range(8):\n        for y in range(8):\n            if get_flips(board, x, y, color):\n                moves.append((x, y))\n    return moves\n\n# çŸ³ã‚’ç½®ã\ndef place_stone(board, x, y, color):\n    flips = get_flips(board, x, y, color)\n    if not flips:\n        return False  # ç½®ã‘ãªã„\n\n    board[x][y] = color\n    for fx, fy in flips:\n        board[fx][fy] = color\n    return True\n\n# ã‚¹ã‚³ã‚¢ã‚’æ•°ãˆã‚‹\ndef count_stones(board):\n    b = sum(row.count(BLACK) for row in board)\n    w = sum(row.count(WHITE) for row in board)\n    return b, w\n\n# ======== ãƒ¡ã‚¤ãƒ³ã‚²ãƒ¼ãƒ ãƒ«ãƒ¼ãƒ— ========\nboard = new_board()\ncurrent = BLACK\n\nprint(\"ã‚ªã‚»ãƒ­ã‚’é–‹å§‹ã—ã¾ã™ï¼\")\nprint_board(board)\n\nwhile True:\n    moves = valid_moves(board, current)\n\n    if not moves:\n        opponent = WHITE if current == BLACK else BLACK\n        opponent_moves = valid_moves(board, opponent)\n\n        if not opponent_moves:\n            print(\"ä¸¡è€…ç½®ã‘ãªã„ãŸã‚ã‚²ãƒ¼ãƒ çµ‚äº†ï¼\")\n            break\n\n        print(f\"{current} ã¯åˆæ³•æ‰‹ãŒãªã„ãŸã‚ãƒ‘ã‚¹ã—ã¾ã™\")\n        current = opponent\n        continue\n\n    print(f\"ç¾åœ¨ã®ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼: {current}\")\n    print_board(board)\n    print(\"åˆæ³•æ‰‹:\", moves)\n\n    # ãƒ¦ãƒ¼ã‚¶ãƒ¼å…¥åŠ›\n    try:\n        x = int(input(\"x åº§æ¨™ï¼ˆ0ã€œ7ï¼‰: \"))\n        y = int(input(\"y åº§æ¨™ï¼ˆ0ã€œ7ï¼‰: \"))\n    except:\n        print(\"æ•°å€¤ã‚’å…¥åŠ›ã—ã¦ãã ã•ã„\")\n        continue\n\n    if (x, y) not in moves:\n        print(\"ãã®å ´æ‰€ã¯ç½®ã‘ã¾ã›ã‚“\")\n        continue\n\n    place_stone(board, x, y, current)\n\n    # ã‚¿ãƒ¼ãƒ³äº¤ä»£\n    current = WHITE if current == BLACK else BLACK\n\n# çµæœè¡¨ç¤º\nprint_board(board)\nb, w = count_stones(board)\nprint(\"æœ€çµ‚ã‚¹ã‚³ã‚¢\")\nprint(f\"é»’(B) : {b}\")\nprint(f\"ç™½(W) : {w}\")\n\nif b > w:\n    print(\"é»’ã®å‹ã¡ï¼\")\nelif w > b:\n    print(\"ç™½ã®å‹ã¡ï¼\")\nelse:\n    print(\"å¼•ãåˆ†ã‘ï¼\")\n"
  },
  {
    "name": "Rami",
    "description": "ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ãŒè‡ªåˆ†ã§è€ƒãˆã¦çŸ³ã‚’ç½®ãã“ã¨ãŒã§ãã€ç½®ã‘ãªã„å ´æ‰€ã®å ´åˆã¯ç½®ã‘ãªã„ã¨è­¦å‘Šã§ãã‚‹ã‚ˆã†ã«ã—ã¦ã„ã¾ã™ã€‚å…¥åŠ›å½¢å¼ã‚’ã‚¢ãƒ«ãƒ•ã‚¡ãƒ™ãƒƒãƒˆã¨æ•°å­—ã®çµ„ã¿åˆã‚ã›ã«ã™ã‚‹ã“ã¨ã§ã€ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ãŒç°¡å˜ã«å…¥åŠ›ã§ãã‚‹ã‚ˆã†ã«ã—ã¦ã„ã¾ã™ã€‚",
    "code": "import numpy as np\n\n# ã‚ªã‚»ãƒ­ãƒœãƒ¼ãƒ‰ã‚’åˆæœŸåŒ–\ndef initialize_board():\n    board = np.zeros((8, 8), dtype=int)\n    board[3][3] = 1  # ç™½\n    board[4][4] = 1  # ç™½\n    board[3][4] = -1 # é»’\n    board[4][3] = -1 # é»’\n    return board\n\n# ãƒœãƒ¼ãƒ‰ã®è¡¨ç¤º\ndef print_board(board):\n    print(\"  a b c d e f g h\")\n    print(\" +----------------\")\n    for row in range(8):\n        print(f\"{row+1}|\", end=\" \")\n        for col in range(8):\n            if board[row, col] == 1:\n                print(\"O\", end=\" \")\n            elif board[row, col] == -1:\n                print(\"X\", end=\" \")\n            else:\n                print(\".\", end=\" \")\n        print()\n\n# æŒ‡å®šä½ç½®ãŒåˆæ³•ã‹ã©ã†ã‹ã‚’ç¢ºèª\ndef is_valid_move(board, row, col, player):\n    if board[row, col] != 0:\n        return False  # ç©ºã„ã¦ã„ãªã„å ´æ‰€ã«ã¯ç½®ã‘ãªã„\n    \n    directions = [(-1, -1), (-1, 0), (-1, 1), (0, -1), (0, 1), (1, -1), (1, 0), (1, 1)]\n    opponent = -player  # ç›¸æ‰‹ã®ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ï¼ˆ1ã¯ç™½ã€-1ã¯é»’ï¼‰\n    valid = False\n    \n    for direction in directions:\n        r, c = row, col\n        r += direction[0]\n        c += direction[1]\n        \n        if 0 <= r < 8 and 0 <= c < 8 and board[r, c] == opponent:\n            r += direction[0]\n            c += direction[1]\n            \n            while 0 <= r < 8 and 0 <= c < 8:\n                if board[r, c] == player:\n                    valid = True  # ç›¸æ‰‹ã®çŸ³ã‚’æŒŸã‚“ã§è‡ªåˆ†ã®çŸ³ãŒç½®ã‘ã‚‹å ´åˆ\n                    break\n                elif board[r, c] == 0:\n                    break  # ç©ºç™½ã®å ´åˆã¯è£è¿”ã›ãªã„\n                r += direction[0]\n                c += direction[1]\n    return valid\n\n# çŸ³ã‚’è£è¿”ã™\ndef flip_stones(board, row, col, player):\n    directions = [(-1, -1), (-1, 0), (-1, 1), (0, -1), (0, 1), (1, -1), (1, 0), (1, 1)]\n    opponent = -player\n    \n    for direction in directions:\n        r, c = row, col\n        r += direction[0]\n        c += direction[1]\n        \n        if 0 <= r < 8 and 0 <= c < 8 and board[r, c] == opponent:\n            stones_to_flip = []\n            r += direction[0]\n            c += direction[1]\n            \n            while 0 <= r < 8 and 0 <= c < 8:\n                if board[r, c] == player:\n                    for flip_r, flip_c in stones_to_flip:\n                        board[flip_r, flip_c] = player\n                    break\n                elif board[r, c] == 0:\n                    break\n                stones_to_flip.append((r, c))\n                r += direction[0]\n                c += direction[1]\n\n# ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®ã‚¿ãƒ¼ãƒ³ï¼ˆçŸ³ã‚’ç½®ãä½ç½®ã‚’æ‰‹å‹•ã§å…¥åŠ›ï¼‰\ndef player_turn(board, player):\n    valid_moves = []\n    for row in range(8):\n        for col in range(8):\n            if is_valid_move(board, row, col, player):\n                valid_moves.append((row, col))\n\n    if valid_moves:\n        # åˆæ³•çš„ãªæ‰‹ã‚’è¡¨ç¤º\n        print(f\"ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼{'é»’' if player == -1 else 'ç™½'}ã®ã‚¿ãƒ¼ãƒ³ã§ã™ã€‚\")\n        print(\"åˆæ³•çš„ãªæ‰‹ã¯æ¬¡ã®é€šã‚Šã§ã™:\")\n        for move in valid_moves:\n            print(f\"({chr(move[1]+97)}, {move[0]+1})\")\n        \n        # ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ãŒå…¥åŠ›\n        while True:\n            user_input = input(f\"çŸ³ã‚’ç½®ãå ´æ‰€ã‚’é¸ã‚“ã§ãã ã•ã„ï¼ˆä¾‹ï¼ša1, h8ãªã©ï¼‰: \").strip().lower()\n            \n            if len(user_input) != 2:\n                print(\"ç„¡åŠ¹ãªå…¥åŠ›ã§ã™ã€‚ã‚‚ã†ä¸€åº¦å…¥åŠ›ã—ã¦ãã ã•ã„ã€‚\")\n                continue\n            \n            col_char, row_str = user_input[0], user_input[1]\n            \n            # åˆ—ã¨è¡Œã®ç•ªå·ã‚’å–å¾—\n            if col_char not in 'abcdefgh' or row_str not in '12345678':\n                print(\"ç„¡åŠ¹ãªå…¥åŠ›ã§ã™ã€‚ã‚‚ã†ä¸€åº¦å…¥åŠ›ã—ã¦ãã ã•ã„ã€‚\")\n                continue\n\n            col = ord(col_char) - ord('a')\n            row = int(row_str) - 1\n            \n            # å…¥åŠ›ã•ã‚ŒãŸä½ç½®ãŒåˆæ³•ã‹ç¢ºèª\n            if (row, col) in valid_moves:\n                print(f\"ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼{'é»’' if player == -1 else 'ç™½'}ã¯ ({col_char}, {row_str}) ã«çŸ³ã‚’ç½®ãã¾ã—ãŸ\")\n                board[row, col] = player\n                flip_stones(board, row, col, player)\n                break\n            else:\n                print(\"ãã®å ´æ‰€ã«ã¯çŸ³ã‚’ç½®ã‘ã¾ã›ã‚“ã€‚ã‚‚ã†ä¸€åº¦å…¥åŠ›ã—ã¦ãã ã•ã„ã€‚\")\n    else:\n        print(f\"ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼{'é»’' if player == -1 else 'ç™½'}ã¯åˆæ³•çš„ãªæ‰‹ãŒã‚ã‚Šã¾ã›ã‚“\")\n\n# ã‚²ãƒ¼ãƒ ã®çµ‚äº†åˆ¤å®š\ndef is_game_over(board):\n    for row in range(8):\n        for col in range(8):\n            if board[row, col] == 0 and (is_valid_move(board, row, col, 1) or is_valid_move(board, row, col, -1)):\n                return False\n    return True\n\n# å‹è€…åˆ¤å®š\ndef check_winner(board):\n    black = np.sum(board == -1)\n    white = np.sum(board == 1)\n    print(f\"é»’ã®çŸ³: {black}, ç™½ã®çŸ³: {white}\")\n    \n    if black > white:\n        print(\"é»’ã®å‹åˆ©!\")\n    elif white > black:\n        print(\"ç™½ã®å‹åˆ©!\")\n    else:\n        print(\"å¼•ãåˆ†ã‘ã§ã™!\")\n\n# ã‚²ãƒ¼ãƒ é–‹å§‹\ndef play_game():\n    board = initialize_board()\n    current_player = -1  # é»’ãŒå…ˆæ‰‹ (-1 = é»’, 1 = ç™½)\n\n    while not is_game_over(board):\n        print_board(board)\n        player_turn(board, current_player)\n        current_player = -current_player  # ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼äº¤ä»£\n    \n    print_board(board)\n    check_winner(board)\n\n# å®Ÿè¡Œ\nplay_game()"
  },
  {
    "name": "Manaka",
    "description": "ã“ã®ãƒ—ãƒ­ã‚°ãƒ©ãƒ ã¯ã€Google Colab ã§å‹•ãç°¡å˜ãªã‚ªã‚»ãƒ­ã‚²ãƒ¼ãƒ ã§ã™ã€‚ 8Ã—8 ã®ç›¤ã‚’ãƒªã‚¹ãƒˆã§ä½œã£ã¦ã€é»’(è‡ªåˆ†)ã¨ç™½(ã‚³ãƒ³ãƒ”ãƒ¥ãƒ¼ã‚¿)ãŒäº¤äº’ã«çŸ³ã‚’ç½®ãã‚ˆã†ã«ã—ã¦ã„ã¾ã™ã€‚ ç›¤é¢ãŒæ¯å›è¡¨ç¤ºã•ã‚Œã‚‹ã®ã§ã€ã©ã“ã«ç½®ã„ãŸã‹åˆ†ã‹ã‚Šã‚„ã™ã„ã‚ˆã†ã«ã—ã¾ã—ãŸã€‚  ğŸ”¶ å·¥å¤«ã—ãŸã¨ã“ã‚  çŸ³ã‚’ç½®ã„ãŸã¨ãã«ã€ç›¸æ‰‹ã®çŸ³ã‚’ã²ã£ãã‚Šè¿”ã™å‡¦ç†ã‚’è‡ªåˆ†ã§æ›¸ã„ã¦ã¿ã¾ã—ãŸã€‚ 8æ–¹å‘ã‚’èª¿ã¹ã‚‹å¿…è¦ãŒã‚ã£ã¦å°‘ã—å¤§å¤‰ã§ã—ãŸãŒã€å‹•ãã‚ˆã†ã«ãªã£ã¦ã‚ˆã‹ã£ãŸã§ã™ã€‚  Colab ã§ã¯ input() ã§æ•°å­—ã‚’ã†ã¾ãå—ã‘å–ã‚Œãªã„ã“ã¨ãŒã‚ã£ãŸã®ã§ã€ 0ã€œ7 ã®æ•°å­—ã ã‘ã‚’å—ã‘ä»˜ã‘ã‚‹ã€Œå®‰å…¨ãªå…¥åŠ›ç”¨ã®é–¢æ•°ã€ã‚’ä½œã£ã¦ã‚¨ãƒ©ãƒ¼ã‚’é˜²ãã¾ã—ãŸã€‚  ã‚³ãƒ³ãƒ”ãƒ¥ãƒ¼ã‚¿ãŒé©å½“ã«çŸ³ã‚’ç½®ã‘ã‚‹ã‚ˆã†ã«ã€æ‰“ã¦ã‚‹å ´æ‰€ã®ä¸­ã‹ã‚‰ãƒ©ãƒ³ãƒ€ãƒ ã§é¸ã¶ä»•çµ„ã¿ã‚’å…¥ã‚Œã¾ã—ãŸã€‚ ã“ã‚Œã§æœ€å¾Œã¾ã§ã‚²ãƒ¼ãƒ ãŒé€²ã‚€ã‚ˆã†ã«ãªã‚Šã¾ã—ãŸã€‚  é–¢æ•°ã‚’ä½•å€‹ã‹ã«åˆ†ã‘ã¦æ›¸ãã€ä½•ã‚’ã—ã¦ã„ã‚‹éƒ¨åˆ†ãªã®ã‹åˆ†ã‹ã‚Šã‚„ã™ãã—ã¾ã—ãŸã€‚ è‡ªåˆ†ã§ã‚‚å¾Œã‹ã‚‰èª­ã‚“ã§ä¿®æ­£ã—ã‚„ã™ã„ã‚ˆã†ã«æ„è­˜ã—ã¾ã—ãŸã€‚",
    "code": "import random\n\n# ------------------------------\n# ç›¤é¢ã®åˆæœŸåŒ–\n# ------------------------------\ndef initialize_board():\n    board = [[\".\" for _ in range(8)] for _ in range(8)]\n    board[3][3] = \"W\"\n    board[3][4] = \"B\"\n    board[4][3] = \"B\"\n    board[4][4] = \"W\"\n    return board\n\n# ------------------------------\n# ç›¤é¢ã®è¡¨ç¤º\n# ------------------------------\ndef print_board(board):\n    print(\"  0 1 2 3 4 5 6 7\")\n    for i in range(8):\n        print(i, \" \".join(board[i]))\n    print()\n\n# ------------------------------\n# æŒ‡å®šã—ãŸä½ç½®ã«ç½®ã‘ã‚‹ã‹åˆ¤å®š\n# ------------------------------\ndirections = [\n    (-1, -1), (-1, 0), (-1, 1),\n    (0, -1),          (0, 1),\n    (1, -1), (1, 0),  (1, 1)\n]\n\ndef is_valid_move(board, row, col, color):\n    if board[row][col] != \".\":\n        return False\n\n    opponent = \"W\" if color == \"B\" else \"B\"\n\n    for dr, dc in directions:\n        r, c = row + dr, col + dc\n        count = 0\n\n        while 0 <= r < 8 and 0 <= c < 8 and board[r][c] == opponent:\n            r += dr\n            c += dc\n            count += 1\n\n        if count > 0 and 0 <= r < 8 and 0 <= c < 8 and board[r][c] == color:\n            return True\n\n    return False\n\n# ------------------------------\n# çŸ³ã‚’ç½®ã„ã¦ã²ã£ãã‚Šè¿”ã™\n# ------------------------------\ndef place_and_flip(board, row, col, color):\n    opponent = \"W\" if color == \"B\" else \"B\"\n    board[row][col] = color\n    for dr, dc in directions:\n        r, c = row + dr, col + dc\n        stones = []\n\n        while 0 <= r < 8 and 0 <= c < 8 and board[r][c] == opponent:\n            stones.append((r, c))\n            r += dr\n            c += dc\n\n        if len(stones) > 0 and 0 <= r < 8 and 0 <= c < 8 and board[r][c] == color:\n            for sr, sc in stones:\n                board[sr][sc] = color\n\n# ------------------------------\n# åˆæ³•æ‰‹ã®ä¸€è¦§\n# ------------------------------\ndef get_valid_moves(board, color):\n    moves = []\n    for r in range(8):\n        for c in range(8):\n            if is_valid_move(board, r, c, color):\n                moves.append((r, c))\n    return moves\n\n# ------------------------------\n# ãƒ¡ã‚¤ãƒ³ã‚²ãƒ¼ãƒ ãƒ«ãƒ¼ãƒ—\n# ------------------------------\ndef play_game():\n    board = initialize_board()\n    turn = \"B\"  # é»’ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã‹ã‚‰é–‹å§‹\n\n    while True:\n        print_board(board)\n\n        moves = get_valid_moves(board, turn)\n\n        # ã‚²ãƒ¼ãƒ çµ‚äº†åˆ¤å®š\n        if len(moves) == 0:\n            print(f\"{turn} ã®åˆæ³•æ‰‹ãŒã‚ã‚Šã¾ã›ã‚“ã€‚ãƒ‘ã‚¹ã—ã¾ã™ã€‚\")\n            turn = \"W\" if turn == \"B\" else \"B\"\n            if len(get_valid_moves(board, turn)) == 0:\n                print(\"ä¸¡è€…ãŒæ‰“ã¦ãªã„ãŸã‚ã‚²ãƒ¼ãƒ çµ‚äº†!\")\n                break\n            continue\n\n        if turn == \"B\":\n            print(\"ã‚ãªãŸã®ç•ªã§ã™ï¼ˆé»’ï¼‰\")\n            print(\"åˆæ³•æ‰‹:\", moves)\n            row = int(input(\"è¡Œã‚’å…¥åŠ› >> \"))\n            col = int(input(\"åˆ—ã‚’å…¥åŠ› >> \"))\n\n            if (row, col) not in moves:\n                print(\"ãã“ã«ã¯ç½®ã‘ã¾ã›ã‚“ã€‚ã‚‚ã†ä¸€åº¦ã€‚\")\n                continue\n\n            place_and_flip(board, row, col, \"B\")\n\n        else:\n            print(\"ã‚³ãƒ³ãƒ”ãƒ¥ãƒ¼ã‚¿ã®ç•ªã§ã™ï¼ˆç™½ï¼‰\")\n            move = random.choice(moves)\n            print(\"ç™½ã®é¸ã‚“ã æ‰‹:\", move)\n            place_and_flip(board, move[0], move[1], \"W\")\n\n        turn = \"W\" if turn == \"B\" else \"B\"\n\n    # çµæœè¡¨ç¤º\n    print_board(board)\n    black = sum(row.count(\"B\") for row in board)\n    white = sum(row.count(\"W\") for row in board)\n    print(f\"é»’: {black}, ç™½: {white}\")\n    print(\"å‹è€…:\", \"é»’\" if black > white else \"ç™½\" if white > black else \"å¼•ãåˆ†ã‘\")\n\n# ------------------------------\n# å®Ÿè¡Œ\n# ------------------------------\nplay_game()\n"
  },
  {
    "name": "Ryoji",
    "description": "ã“ã®ãƒ—ãƒ­ã‚°ãƒ©ãƒ ã¯ãƒ†ã‚­ã‚¹ãƒˆãƒ™ãƒ¼ã‚¹ã§å‹•ä½œã™ã‚‹ã‚ªã‚»ãƒ­ã‚²ãƒ¼ãƒ ã§ã™ã€‚ Google Colab ã§å®Ÿè¡Œã§ãã‚‹ã‚ˆã†ã«ã€GUI ã‚’ä½¿ã‚ãšæ¨™æº–å…¥åŠ›ã¨æ¨™æº–å‡ºåŠ›ã§å‹•ä½œã™ã‚‹ã‚ˆã†ã«ã—ã¾ã—ãŸã€‚  å·¥å¤«ã—ãŸç‚¹:  ã‚³ãƒ¼ãƒ‰ã‚’ç†è§£ã—ã‚„ã™ã„ã‚ˆã†ã«ã€é–¢æ•°ã‚’ç´°ã‹ãåˆ†å‰²(ç›¤é¢åˆæœŸåŒ–ã€åˆæ³•æ‰‹åˆ¤å®šã€çŸ³ã®åè»¢ã€è¡¨ç¤ºãªã©)ã€‚  æ–¹å‘ãƒ™ã‚¯ãƒˆãƒ«ã‚’ 8 æ–¹å‘ã¾ã¨ã‚ã¦è¨˜è¿°ã—ã€åè»¢å‡¦ç†ã‚’ç°¡æ½”ã«å®Ÿè£…ã€‚  äººé–“åŒå£«ã®å¯¾æˆ¦ã«ã—ã¦ã€å¾Œã§ CPU ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã‚’è¿½åŠ ã§ãã‚‹ã‚ˆã†æ‹¡å¼µã—ã‚„ã™ã„æ§‹é€ ã€‚  Colab ã§å®Ÿè¡Œã™ã‚‹ã ã‘ã§ã‚ªã‚»ãƒ­ãŒéŠã¹ã‚‹ã‚ˆã†ã« play_othello() ã‚’ç”¨æ„ã€‚",
    "code": "# ===== ã‚ªã‚»ãƒ­ã‚²ãƒ¼ãƒ ï¼ˆGoogle Colabç”¨ãƒ»ãƒ†ã‚­ã‚¹ãƒˆãƒ™ãƒ¼ã‚¹ï¼‰ =====\n# ã§ãã‚‹ã ã‘ç†è§£ã—ã‚„ã™ã„æ§‹é€ ã§ä½œæˆ\n# ç›¤é¢ç®¡ç†ã€åˆæ³•æ‰‹åˆ¤å®šã€çŸ³ã®åè»¢ã€ã‚²ãƒ¼ãƒ ãƒ«ãƒ¼ãƒ—ã‚’å®Ÿè£…\n\n# --- ãƒ©ã‚¤ãƒ–ãƒ©ãƒªãªã—ã§å‹•ãç°¡æ˜“ç‰ˆã‚ªã‚»ãƒ­ ---\n\n# ç›¤é¢åˆæœŸåŒ– (8x8)\ndef init_board():\n    board = [[\".\" for _ in range(8)] for _ in range(8)]\n    board[3][3] = \"W\"\n    board[3][4] = \"B\"\n    board[4][3] = \"B\"\n    board[4][4] = \"W\"\n    return board\n\n# ç›¤é¢è¡¨ç¤º\ndef print_board(board):\n    print(\"  0 1 2 3 4 5 6 7\")\n    for i, row in enumerate(board):\n        print(i, \" \".join(row))\n    print()\n\n# çŸ³ã‚’ç½®ã‘ã‚‹æ–¹å‘ï¼ˆ8æ–¹å‘ï¼‰\ndirections = [(-1, -1), (-1, 0), (-1, 1), (0, -1), (0, 1), (1, -1), (1, 0), (1, 1)]\n\n# åˆæ³•æ‰‹åˆ¤å®š\ndef valid_moves(board, player):\n    opponent = \"W\" if player == \"B\" else \"B\"\n    moves = []\n\n    for r in range(8):\n        for c in range(8):\n            if board[r][c] != \".\":\n                continue\n\n            valid = False\n            for dr, dc in directions:\n                nr, nc = r + dr, c + dc\n                count = 0\n                while 0 <= nr < 8 and 0 <= nc < 8 and board[nr][nc] == opponent:\n                    nr += dr\n                    nc += dc\n                    count += 1\n                if count > 0 and 0 <= nr < 8 and 0 <= nc < 8 and board[nr][nc] == player:\n                    valid = True\n                    break\n            if valid:\n                moves.append((r, c))\n    return moves\n\n# çŸ³ã‚’ç½®ã + åè»¢å‡¦ç†\ndef place_piece(board, r, c, player):\n    opponent = \"W\" if player == \"B\" else \"B\"\n    board[r][c] = player\n\n    for dr, dc in directions:\n        nr, nc = r + dr, c + dc\n        flip_list = []\n        while 0 <= nr < 8 and 0 <= nc < 8 and board[nr][nc] == opponent:\n            flip_list.append((nr, nc))\n            nr += dr\n            nc += dc\n        if flip_list and 0 <= nr < 8 and 0 <= nc < 8 and board[nr][nc] == player:\n            for fr, fc in flip_list:\n                board[fr][fc] = player\n\n# ã‚¹ã‚³ã‚¢è¨ˆç®—\ndef count_stones(board):\n    blacks = sum(row.count(\"B\") for row in board)\n    whites = sum(row.count(\"W\") for row in board)\n    return blacks, whites\n\n# ãƒ¡ã‚¤ãƒ³ã‚²ãƒ¼ãƒ ãƒ«ãƒ¼ãƒ—ï¼ˆäºº vs äººï¼‰\ndef play_othello():\n    board = init_board()\n    player = \"B\"  # å…ˆæ‰‹ï¼šé»’\n\n    while True:\n        print_board(board)\n        blacks, whites = count_stones(board)\n        print(f\"é»’(B): {blacks}  ç™½(W): {whites}\")\n        print(f\"ç¾åœ¨ã®æ‰‹ç•ª: {player}\")\n\n        moves = valid_moves(board, player)\n        if not moves:\n            print(f\"{player} ã¯ç½®ã‘ã‚‹å ´æ‰€ãŒã‚ã‚Šã¾ã›ã‚“ â†’ ãƒ‘ã‚¹ã—ã¾ã™\\n\")\n            player = \"W\" if player == \"B\" else \"B\"\n            if not valid_moves(board, player):\n                print(\"ä¸¡è€…ã¨ã‚‚ç½®ã‘ãªã„ãŸã‚ã‚²ãƒ¼ãƒ çµ‚äº†ï¼\")\n                break\n            continue\n\n        print(\"åˆæ³•æ‰‹:\", moves)\n\n        # å…¥åŠ›å—ä»˜\n        try:\n            r = int(input(\"è¡Œã‚’å…¥åŠ› (0-7): \"))\n            c = int(input(\"åˆ—ã‚’å…¥åŠ› (0-7): \"))\n        except:\n            print(\"æ•°å­—ã‚’å…¥åŠ›ã—ã¦ãã ã•ã„\\n\")\n            continue\n\n        if (r, c) not in moves:\n            print(\"ãã“ã«ã¯ç½®ã‘ã¾ã›ã‚“ï¼\\n\")\n            continue\n\n        place_piece(board, r, c, player)\n\n        # æ‰‹ç•ªäº¤ä»£\n        player = \"W\" if player == \"B\" else \"B\"\n\n    # æœ€çµ‚ç›¤é¢è¡¨ç¤º\n    print_board(board)\n    blacks, whites = count_stones(board)\n    print(f\"æœ€çµ‚ã‚¹ã‚³ã‚¢ â†’ é»’: {blacks}, ç™½: {whites}\")\n    if blacks > whites:\n        print(\"é»’ã®å‹ã¡ï¼\")\n    elif whites > blacks:\n        print(\"ç™½ã®å‹ã¡ï¼\")\n    else:\n        print(\"å¼•ãåˆ†ã‘ï¼\")\n\n# å®Ÿè¡Œ\ntest_run = False\nif test_run:\n    play_othello()\n"
  },
  {
    "name": "Ishiyama",
    "description": "æœ¬èª²é¡Œã§ã¯,ã‚ªã‚»ãƒ­(Reversi)ã®åŸºç¤çš„ãªã‚¨ãƒ³ã‚¸ãƒ³ã‚’ Python ã§å®Ÿè£…ã—ãŸ.ç›¤ã¯ 8Ã—8,åˆæœŸé…ç½®ã¯æ¨™æº–é…ç½®ã‚’æ¡ç”¨ã—,çŸ³ã‚’ç½®ã‘ã‚‹åˆæ³•æ‰‹ã®æ¢ç´¢ã¨,ç½®ã„ãŸéš›ã®ã²ã£ãã‚Šè¿”ã—å‡¦ç†ã‚’æ­£ç¢ºã«è¡Œã†ã‚¢ãƒ«ã‚´ãƒªã‚ºãƒ ã‚’å®Ÿè£…ã—ãŸ.åˆæ³•æ‰‹åˆ¤å®šã¯,8æ–¹å‘ã«å¯¾ã—ã¦ç›¸æ‰‹çŸ³ãŒé€£ç¶šã—,ã•ã‚‰ã«ãã®å…ˆã«è‡ªåˆ†ã®çŸ³ãŒå­˜åœ¨ã™ã‚‹ã‹ã‚’èª¿ã¹ã‚‹æ–¹æ³•ã§è¡Œã£ãŸ.ãƒ‡ãƒ¢å®Ÿè¡Œã¯ãƒ©ãƒ³ãƒ€ãƒ ã«åˆæ³•æ‰‹ã‚’é¸ã¶ç°¡æ˜“ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼åŒå£«ã§è¡Œã„,é€”ä¸­ã®ç›¤é¢ã¨æœ€çµ‚ã‚¹ã‚³ã‚¢ã‚’å‡ºåŠ›ã™ã‚‹ã€‚",
    "code": "# othello_game.py\n# Simple Othello (Reversi) engine and random-play demo.\n# Save this file and run: python othello_game.py\n\nimport random\n\nclass Othello:\n    EMPTY = 0\n    BLACK = 1\n    WHITE = 2\n    DIRS = [(-1,-1),(-1,0),(-1,1),(0,-1),(0,1),(1,-1),(1,0),(1,1)]\n\n    def __init__(self, size=8):\n        self.size = size\n        self.board = [[Othello.EMPTY]*size for _ in range(size)]\n        mid = size // 2\n        # standard starting position\n        self.board[mid-1][mid-1] = Othello.WHITE\n        self.board[mid][mid]       = Othello.WHITE\n        self.board[mid-1][mid]     = Othello.BLACK\n        self.board[mid][mid-1]     = Othello.BLACK\n\n    def on_board(self, r, c):\n        return 0 <= r < self.size and 0 <= c < self.size\n\n    def valid_moves(self, player):\n        moves = []\n        opp = Othello.BLACK if player == Othello.WHITE else Othello.WHITE\n        for r in range(self.size):\n            for c in range(self.size):\n                if self.board[r][c] != Othello.EMPTY:\n                    continue\n                ok = False\n                for dr,dc in Othello.DIRS:\n                    rr,cc = r+dr, c+dc\n                    found_opp = False\n                    while self.on_board(rr,cc) and self.board[rr][cc] == opp:\n                        found_opp = True\n                        rr += dr; cc += dc\n                    if found_opp and self.on_board(rr,cc) and self.board[rr][cc] == player:\n                        ok = True\n                        break\n                if ok:\n                    moves.append((r,c))\n        return moves\n\n    def apply_move(self, r, c, player):\n        # assumes move is valid\n        self.board[r][c] = player\n        opp = Othello.BLACK if player == Othello.WHITE else Othello.WHITE\n        for dr,dc in Othello.DIRS:\n            rr,cc = r+dr, c+dc\n            path = []\n            while self.on_board(rr,cc) and self.board[rr][cc] == opp:\n                path.append((rr,cc))\n                rr += dr; cc += dc\n            if path and self.on_board(rr,cc) and self.board[rr][cc] == player:\n                for pr,pc in path:\n                    self.board[pr][pc] = player\n\n    def score(self):\n        b = sum(1 for r in range(self.size) for c in range(self.size) if self.board[r][c]==Othello.BLACK)\n        w = sum(1 for r in range(self.size) for c in range(self.size) if self.board[r][c]==Othello.WHITE)\n        return b, w\n\n    def print_board(self):\n        # print header\n        print(\"  \" + \" \".join(str(i) for i in range(self.size)))\n        for r in range(self.size):\n            line = []\n            for c in range(self.size):\n                v = self.board[r][c]\n                if v == Othello.EMPTY: ch = \".\"\n                elif v == Othello.BLACK: ch = \"B\"\n                else: ch = \"W\"\n                line.append(ch)\n            print(f\"{r} \" + \" \".join(line))\n\nif __name__ == \"__main__\":\n    random.seed(42)\n    g = Othello()\n    current = Othello.BLACK\n    moves_done = 0\n    max_moves = 60  # safety cap\n\n    while moves_done < max_moves:\n        moves = g.valid_moves(current)\n        if not moves:\n            # pass\n            current = Othello.BLACK if current == Othello.WHITE else Othello.WHITE\n            if not g.valid_moves(current):  # both passed -> end\n                break\n            continue\n        mv = random.choice(moves)\n        g.apply_move(mv[0], mv[1], current)\n        moves_done += 1\n        current = Othello.BLACK if current == Othello.WHITE else Othello.WHITE\n\n    g.print_board()\n    b,w = g.score()\n    print(\"Score -> Black:\", b, \"White:\", w)"
  },
  {
    "name": "Aoto",
    "description": "Google Colab ä¸Šã§ç°¡å˜ã«å®Ÿè¡Œã§ãã‚‹ã“ã¨ã‚’æœ€å„ªå…ˆã«ã—ãŸ  ã‚°ãƒ©ãƒ•ã‚£ãƒƒã‚¯è¡¨ç¤ºã§ã¯ãªãã€ãƒ†ã‚­ã‚¹ãƒˆãƒ™ãƒ¼ã‚¹ã§ã‚ªã‚»ãƒ­ãŒå‹•ãã‚ˆã†ã«ã—ãŸ  ã‚³ãƒ¼ãƒ‰ã‚’ç†è§£ã—ã‚„ã™ã„ã‚ˆã†ã«ã€é–¢æ•°ã‚’ç´°ã‹ãåˆ†ã‘ã¦å®Ÿè£…",
    "code": "import numpy as np\n\n# --- å®šæ•° ---\nEMPTY = 0\nBLACK = 1\nWHITE = -1\n\n# --- æ–¹å‘ï¼ˆ8æ–¹å‘ï¼‰ ---\nDIRECTIONS = [\n    (-1, 0), (1, 0), (0, -1), (0, 1),\n    (-1, -1), (-1, 1), (1, -1), (1, 1)\n]\n\n# --- åˆæœŸç›¤é¢ ---\ndef init_board():\n    board = np.zeros((8,8), dtype=int)\n    board[3,3] = WHITE\n    board[3,4] = BLACK\n    board[4,3] = BLACK\n    board[4,4] = WHITE\n    return board\n\n# --- ç›¤é¢è¡¨ç¤º ---\ndef print_board(board):\n    print(\"  0 1 2 3 4 5 6 7\")\n    for i in range(8):\n        row = \"\"\n        for j in range(8):\n            if board[i][j] == BLACK:\n                row += \" B\"\n            elif board[i][j] == WHITE:\n                row += \" W\"\n            else:\n                row += \" .\"\n        print(i, row)\n\n# --- åˆæ³•æ‰‹ã®å–å¾— ---\ndef get_valid_moves(board, player):\n    moves = []\n    for r in range(8):\n        for c in range(8):\n            if board[r][c] == EMPTY and can_flip(board, r, c, player):\n                moves.append((r, c))\n    return moves\n\n# --- çŸ³ãŒã²ã£ãã‚Šè¿”ã›ã‚‹ã‹ç¢ºèª ---\ndef can_flip(board, r, c, player):\n    opponent = -player\n    for dr, dc in DIRECTIONS:\n        nr, nc = r + dr, c + dc\n        found_opponent = False\n\n        while 0 <= nr < 8 and 0 <= nc < 8:\n            if board[nr][nc] == opponent:\n                found_opponent = True\n                nr += dr\n                nc += dc\n            elif board[nr][nc] == player and found_opponent:\n                return True\n            else:\n                break\n    return False\n\n# --- çŸ³ã‚’ç½®ã„ã¦ã²ã£ãã‚Šè¿”ã™ ---\ndef place_and_flip(board, r, c, player):\n    board[r][c] = player\n    opponent = -player\n\n    for dr, dc in DIRECTIONS:\n        nr, nc = r + dr, c + dc\n        flip_list = []\n\n        while 0 <= nr < 8 and 0 <= nc < 8:\n            if board[nr][nc] == opponent:\n                flip_list.append((nr, nc))\n                nr += dr\n                nc += dc\n            elif board[nr][nc] == player:\n                for fr, fc in flip_list:\n                    board[fr][fc] = player\n                break\n            else:\n                break\n\n# --- CPUï¼šãƒ©ãƒ³ãƒ€ãƒ AI ---\nimport random\ndef cpu_move(board, player):\n    moves = get_valid_moves(board, player)\n    if not moves:\n        return None\n    return random.choice(moves)\n\n# --- ãƒ¡ã‚¤ãƒ³ã‚²ãƒ¼ãƒ  ---\nboard = init_board()\nplayer = BLACK  # é»’ãŒå…ˆæ‰‹ï¼ˆã‚ãªãŸï¼‰\nprint(\"ã‚ªã‚»ãƒ­ã‚²ãƒ¼ãƒ é–‹å§‹ï¼ï¼ˆã‚ãªãŸï¼šé»’ B  / CPUï¼šç™½ Wï¼‰\")\n\nwhile True:\n    print(\"\\nç¾åœ¨ã®ç›¤é¢ï¼š\")\n    print_board(board)\n\n    valid_moves = get_valid_moves(board, player)\n\n    if not valid_moves:\n        print(\"åˆæ³•æ‰‹ãŒã‚ã‚Šã¾ã›ã‚“ã€‚ãƒ‘ã‚¹ã—ã¾ã™ã€‚\")\n        player = -player\n        if not get_valid_moves(board, player):\n            print(\"\\nä¸¡è€…ãƒ‘ã‚¹ã«ãªã‚Šã¾ã—ãŸã€‚ã‚²ãƒ¼ãƒ çµ‚äº†ï¼\")\n            break\n        continue\n\n    # --- äººé–“ã®æ‰‹ ---\n    if player == BLACK:\n        print(\"\\nã‚ãªãŸã®ç•ªï¼ˆé»’ Bï¼‰\")\n        print(\"åˆæ³•æ‰‹ï¼š\", valid_moves)\n        r, c = map(int, input(\"(è¡Œ åˆ—) ã‚’ç©ºç™½åŒºåˆ‡ã‚Šã§å…¥åŠ›ã—ã¦ãã ã•ã„ï¼š\").split())\n        if (r, c) not in valid_moves:\n            print(\"ãã®å ´æ‰€ã«ã¯ç½®ã‘ã¾ã›ã‚“ã€‚ã‚‚ã†ä¸€åº¦ã€‚\")\n            continue\n        place_and_flip(board, r, c, player)\n\n    # --- CPUã®æ‰‹ ---\n    else:\n        print(\"\\nCPUï¼ˆç™½ Wï¼‰ã®ç•ªã§ã™...\")\n        move = cpu_move(board, player)\n        if move is None:\n            print(\"CPUã¯ãƒ‘ã‚¹ã—ã¾ã—ãŸã€‚\")\n        else:\n            r, c = move\n            print(f\"CPUãŒç½®ã„ãŸä½ç½®ï¼š({r}, {c})\")\n            place_and_flip(board, r, c, player)\n\n    player = -player\n\n# --- å‹æ•—åˆ¤å®š ---\nblack_count = np.sum(board == BLACK)\nwhite_count = np.sum(board == WHITE)\nprint(\"\\næœ€çµ‚ç›¤é¢ï¼š\")\nprint_board(board)\nprint(f\"\\né»’ï¼ˆã‚ãªãŸï¼‰ï¼š{black_count}   ç™½ï¼ˆCPUï¼‰ï¼š{white_count}\")\n\nif black_count > white_count:\n    print(\"ã‚ãªãŸã®å‹ã¡ï¼\")\nelif black_count < white_count:\n    print(\"CPUã®å‹ã¡ï¼\")\nelse:\n    print(\"å¼•ãåˆ†ã‘ï¼\")\n"
  },
  {
    "name": "Ibuki",
    "description": "1 ã‚³ãƒ¼ãƒ‰ã‚’ç†è§£ã—ã‚„ã™ãã™ã‚‹ãŸã‚ã«ã€ã§ãã‚‹ã ã‘é–¢æ•°ã‚’åˆ†ã‘ãŸ \tâ€¢\tinit_board():åˆæœŸç›¤é¢ \tâ€¢\tprint_board():ç›¤é¢è¡¨ç¤º \tâ€¢\tget_legal_moves():åˆæ³•æ‰‹ãƒã‚§ãƒƒã‚¯ \tâ€¢\tget_flips():ã²ã£ãã‚Šè¿”ã‚‹çŸ³ã®æ¢ç´¢ \tâ€¢\tplace_stone():çŸ³ã‚’ç½®ã„ã¦åè»¢å‡¦ç† \tâ€¢\tplay_game():ã‚²ãƒ¼ãƒ å…¨ä½“  2 æ–¹å‘ãƒ™ã‚¯ãƒˆãƒ«(8æ–¹å‘)ã‚’ä½¿ã£ã¦ã‚·ãƒ³ãƒ—ãƒ«ã«å®Ÿè£… ã‚ªã‚»ãƒ­ã®ãƒ­ã‚¸ãƒƒã‚¯ã¯ã€Œ8æ–¹å‘ã®ç¢ºèªã€ãªã®ã§ã€ãã‚Œã‚’ DIRECTIONS ã§ã¾ã¨ã‚ã¦ for ã§å›ã™æ§‹é€ ã«ã—ã¦ã„ã¾ã™ã€‚  3 æ”¹è‰¯ã—ã‚„ã™ã„è¨­è¨ˆ \tâ€¢\tç›¤é¢ã‚µã‚¤ã‚ºå¤‰æ›´ã‚‚å¯èƒ½ \tâ€¢\tCPUè¿½åŠ ã‚‚å®¹æ˜“(ãƒ©ãƒ³ãƒ€ãƒ /ãƒŸãƒ‹ãƒãƒƒã‚¯ã‚¹ãªã©) \tâ€¢\tGUI åŒ–(pygame ãªã©)ã‚‚å¾Œã§è¿½åŠ ã—ã‚„ã™ã„",
    "code": "# ===== ã‚ªã‚»ãƒ­ï¼ˆãƒªãƒãƒ¼ã‚·ï¼‰ã‚²ãƒ¼ãƒ  =====\n# Google Colabã§ãã®ã¾ã¾å‹•ä½œã—ã¾ã™\n# ------------------------------------\n\n# ç›¤é¢ã‚µã‚¤ã‚ºï¼ˆé€šå¸¸ã¯8ï¼‰\nSIZE = 8\n\n# çŸ³ã®ç¨®é¡\nEMPTY = \".\"\nBLACK = \"B\"\nWHITE = \"W\"\n\n# 8æ–¹å‘ã®ãƒ™ã‚¯ãƒˆãƒ«\nDIRECTIONS = [\n    (-1, -1), (-1, 0), (-1, 1),\n    (0, -1),          (0, 1),\n    (1, -1),  (1, 0), (1, 1)\n]\n\n# ------------------------------------\n# ç›¤é¢åˆæœŸåŒ–\ndef init_board():\n    board = [[EMPTY] * SIZE for _ in range(SIZE)]\n    mid = SIZE // 2\n    board[mid-1][mid-1] = WHITE\n    board[mid][mid] = WHITE\n    board[mid-1][mid] = BLACK\n    board[mid][mid-1] = BLACK\n    return board\n\n# ç›¤é¢è¡¨ç¤º\ndef print_board(board):\n    print(\"  \" + \" \".join(map(str, range(SIZE))))\n    for i, row in enumerate(board):\n        print(i, \" \".join(row))\n\n# ç›¤é¢ã®ç¯„å›²ãƒã‚§ãƒƒã‚¯\ndef in_board(x, y):\n    return 0 <= x < SIZE and 0 <= y < SIZE\n\n# ç½®ã„ãŸæ™‚ã«ã²ã£ãã‚Šè¿”ã‚‹çŸ³ã‚’ãƒªã‚¹ãƒˆã§è¿”ã™\ndef get_flips(board, x, y, color):\n    if board[x][y] != EMPTY:\n        return []\n\n    opponent = WHITE if color == BLACK else BLACK\n    flips = []\n\n    for dx, dy in DIRECTIONS:\n        nx, ny = x + dx, y + dy\n        temp = []\n\n        while in_board(nx, ny) and board[nx][ny] == opponent:\n            temp.append((nx, ny))\n            nx += dx\n            ny += dy\n\n        if in_board(nx, ny) and board[nx][ny] == color and len(temp) > 0:\n            flips.extend(temp)\n\n    return flips\n\n# åˆæ³•æ‰‹ä¸€è¦§ã‚’è¿”ã™\ndef get_legal_moves(board, color):\n    moves = []\n    for x in range(SIZE):\n        for y in range(SIZE):\n            if get_flips(board, x, y, color):\n                moves.append((x, y))\n    return moves\n\n# çŸ³ã‚’ç½®ã\ndef place_stone(board, x, y, color):\n    flips = get_flips(board, x, y, color)\n    if not flips:\n        return False\n    board[x][y] = color\n    for fx, fy in flips:\n        board[fx][fy] = color\n    return True\n\n# ã‚²ãƒ¼ãƒ ãƒ¡ã‚¤ãƒ³ãƒ«ãƒ¼ãƒ—\ndef play_game():\n    board = init_board()\n    current_player = BLACK\n\n    while True:\n        print_board(board)\n        moves = get_legal_moves(board, current_player)\n\n        if not moves:\n            print(f\"{current_player} ã«åˆæ³•æ‰‹ãŒã‚ã‚Šã¾ã›ã‚“ã€‚ãƒ‘ã‚¹ã—ã¾ã™ã€‚\")\n            current_player = WHITE if current_player == BLACK else BLACK\n            moves = get_legal_moves(board, current_player)\n            if not moves:\n                print(\"ä¸¡è€…æ‰‹ãŒãªã„ãŸã‚ã‚²ãƒ¼ãƒ çµ‚äº†ã€‚\")\n                break\n        print(f\"\\nç¾åœ¨ã®æ‰‹ç•ª: {current_player}\")\n        print(\"åˆæ³•æ‰‹:\", moves)\n\n        # å…¥åŠ›\n        try:\n            x = int(input(\"xåº§æ¨™: \"))\n            y = int(input(\"yåº§æ¨™: \"))\n        except:\n            print(\"æ•°å€¤ã‚’å…¥åŠ›ã—ã¦ãã ã•ã„ã€‚\")\n            continue\n\n        if (x, y) not in moves:\n            print(\"ãã®æ‰‹ã¯åˆæ³•ã§ã¯ã‚ã‚Šã¾ã›ã‚“ã€‚ã‚„ã‚Šç›´ã—ã¦ãã ã•ã„ã€‚\\n\")\n            continue\n\n        place_stone(board, x, y, current_player)\n        current_player = WHITE if current_player == BLACK else BLACK\n\n    # çµæœ\n    flat = sum(board, [])\n    black_count = flat.count(BLACK)\n    white_count = flat.count(WHITE)\n    print_board(board)\n    print(\"\\n===== ã‚²ãƒ¼ãƒ çµæœ =====\")\n    print(f\"é»’(B): {black_count}, ç™½(W): {white_count}\")\n\n    if black_count > white_count:\n        print(\"é»’ã®å‹ã¡ï¼\")\n    elif white_count > black_count:\n        print(\"ç™½ã®å‹ã¡ï¼\")\n    else:\n        print(\"å¼•ãåˆ†ã‘ï¼\")\n\n# å®Ÿè¡Œ\nplay_game()"
  }
]